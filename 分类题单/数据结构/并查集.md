这篇文章是关于**并查集**的题单。

## AcWing836 合并集合
[传送门](https://www.acwing.com/problem/content/838/) \
路径压缩：
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int p[N], n, m;

int find(int x) {
    if (x != p[x])  p[x] = find(p[x]);
    return p[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++ i)  p[i] = i;
    while (m -- ) {
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        a = find(a), b = find(b);
        if (*op == 'M') {
            if (a == b) continue;
            p[a] = b;
        } else {
            puts(a == b ? "Yes" : "No");
        }
    }
}
```

启发式合并：
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int p[N], sz[N], n, m;

int find(int x) {
    if (x != p[x])  p[x] = find(p[x]);
    return p[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++ i)  p[i] = i, sz[i] = 1; 
    while (m -- ) {
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        a = find(a), b = find(b);
        if (*op == 'M') {
            if (a == b) continue;
            if (sz[a] > sz[b])  swap(a, b);
            p[a] = b;
            sz[b] += sz[a];
        } else {
            puts(a == b ? "Yes" : "No");
        }
    }
}
```

按深度合并：
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int p[N], dep[N], n, m;

int find(int x) {
    if (x != p[x])  p[x] = find(p[x]);
    return p[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++ i)  p[i] = i; 
    while (m -- ) {
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        a = find(a), b = find(b);
        if (*op == 'M') {
            if (a == b) continue;
            if (dep[a] > dep[b])  swap(a, b);
            p[a] = b;
            if (dep[a] == dep[b])   ++ dep[b];
        } else {
            puts(a == b ? "Yes" : "No");
        }
    }
}
```
