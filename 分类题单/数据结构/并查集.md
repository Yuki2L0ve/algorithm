这篇文章是关于**并查集**的题单。

## AcWing836 合并集合
[传送门](https://www.acwing.com/problem/content/838/) \
路径压缩：
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int p[N], n, m;

int find(int x) {
    if (x != p[x])  p[x] = find(p[x]);
    return p[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++ i)  p[i] = i;
    while (m -- ) {
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        a = find(a), b = find(b);
        if (*op == 'M') {
            if (a == b) continue;
            p[a] = b;
        } else {
            puts(a == b ? "Yes" : "No");
        }
    }
}
```

启发式合并：
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int p[N], sz[N], n, m;

int find(int x) {
    if (x != p[x])  p[x] = find(p[x]);
    return p[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++ i)  p[i] = i, sz[i] = 1; 
    while (m -- ) {
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        a = find(a), b = find(b);
        if (*op == 'M') {
            if (a == b) continue;
            if (sz[a] > sz[b])  swap(a, b);
            p[a] = b;
            sz[b] += sz[a];
        } else {
            puts(a == b ? "Yes" : "No");
        }
    }
}
```

按深度合并：
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int p[N], dep[N], n, m;

int find(int x) {
    if (x != p[x])  p[x] = find(p[x]);
    return p[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++ i)  p[i] = i; 
    while (m -- ) {
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        a = find(a), b = find(b);
        if (*op == 'M') {
            if (a == b) continue;
            if (dep[a] > dep[b])  swap(a, b);
            p[a] = b;
            if (dep[a] == dep[b])   ++ dep[b];
        } else {
            puts(a == b ? "Yes" : "No");
        }
    }
}
```


## AcWing837 连通块中点的数量
[传送门](https://www.acwing.com/problem/content/839/)
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int p[N], sz[N], n, m;

int find(int x) {
    if (x != p[x])  p[x] = find(p[x]);
    return p[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++ i)  p[i] = i, sz[i] = 1;
    while (m -- ) {
        string op;
        int a, b;
        cin >> op;
        if (op == "C") {
            scanf("%d%d", &a, &b);
            a = find(a), b = find(b);
            if (a == b) continue;
            if (sz[a] > sz[b])  swap(a, b);
            p[a] = b;
            sz[b] += sz[a];
        } else if (op == "Q1") {
            scanf("%d%d", &a, &b);
            puts(find(a) == find(b) ? "Yes" : "No");
        } else {
            scanf("%d", &a);
            printf("%d\n", sz[find(a)]);
        }
    }
}
```

## AcWing240 食物链
[传送门](https://www.acwing.com/problem/content/242/)
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 50010;
int p[N], dep[N], n, m, ans;

int find(int x) {
    if (x != p[x]) {
        int fa = find(p[x]);    // 找到x所在集合的代表元fa
        dep[x] = (dep[x] + dep[p[x]]) % 3;
        p[x] = fa;
    }
    return p[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++ i)  p[i] = i, dep[i] = 0;
    while (m -- ) {
        int c, x, y;
        scanf("%d%d%d", &c, &x, &y);
        // x或y大于n,或者是x吃y,并且x==y,即同类吃同类  则为假话
        if (x > n || y > n || (c == 2 && x == y)) {
            ++ ans;
        } else {
            int a = find(x), b = find(y);
            if (a == b) {   // 如果集合号相同,说明x和y在同一个集合中,那么不需要合并
                if ((dep[x] - dep[y] + 3) % 3 != c - 1)
                    ++ ans ;
            } else {    // 否则说明集合号不同,说明x和y不在同一个集合中,那么就需要进行合并操作了
                p[a] = b;
                dep[a] = (dep[y] - dep[x] + 3 + c - 1) % 3;
            }
        }
    }
    printf("%d\n", ans);
}
```

## P1892 团伙
[传送门](https://www.luogu.com.cn/problem/P1892)
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 2010;
int p[N], n, m, ans;

int find(int x) {
    if (x != p[x])  p[x] = find(p[x]);
    return p[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= 2 * n; ++ i)   p[i] = i;
    
    while (m -- ) {
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        if (*op == 'F') {
            p[find(a)] = find(b);
        } else {
            p[find(a + n)] = find(b);
            p[find(b + n)] = find(a);
        }
    }
    
    for (int i = 1; i <= n; ++ i)
        if (p[i] == i)
            ++ ans;
    printf("%d\n", ans);
}
```
