这篇文章是关于**并查集**的题单。

## AcWing836 合并集合
[传送门](https://www.acwing.com/problem/content/838/) \
路径压缩：
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int p[N], n, m;

int find(int x) {
    if (x != p[x])  p[x] = find(p[x]);
    return p[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++ i)  p[i] = i;
    while (m -- ) {
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        a = find(a), b = find(b);
        if (*op == 'M') {
            if (a == b) continue;
            p[a] = b;
        } else {
            puts(a == b ? "Yes" : "No");
        }
    }
}
```

启发式合并：
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int p[N], sz[N], n, m;

int find(int x) {
    if (x != p[x])  p[x] = find(p[x]);
    return p[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++ i)  p[i] = i, sz[i] = 1; 
    while (m -- ) {
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        a = find(a), b = find(b);
        if (*op == 'M') {
            if (a == b) continue;
            if (sz[a] > sz[b])  swap(a, b);
            p[a] = b;
            sz[b] += sz[a];
        } else {
            puts(a == b ? "Yes" : "No");
        }
    }
}
```

按深度合并：
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int p[N], dep[N], n, m;

int find(int x) {
    if (x != p[x])  p[x] = find(p[x]);
    return p[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++ i)  p[i] = i; 
    while (m -- ) {
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        a = find(a), b = find(b);
        if (*op == 'M') {
            if (a == b) continue;
            if (dep[a] > dep[b])  swap(a, b);
            p[a] = b;
            if (dep[a] == dep[b])   ++ dep[b];
        } else {
            puts(a == b ? "Yes" : "No");
        }
    }
}
```


## AcWing837 连通块中点的数量
[传送门](https://www.acwing.com/problem/content/839/)
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int p[N], sz[N], n, m;

int find(int x) {
    if (x != p[x])  p[x] = find(p[x]);
    return p[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++ i)  p[i] = i, sz[i] = 1;
    while (m -- ) {
        string op;
        int a, b;
        cin >> op;
        if (op == "C") {
            scanf("%d%d", &a, &b);
            a = find(a), b = find(b);
            if (a == b) continue;
            if (sz[a] > sz[b])  swap(a, b);
            p[a] = b;
            sz[b] += sz[a];
        } else if (op == "Q1") {
            scanf("%d%d", &a, &b);
            puts(find(a) == find(b) ? "Yes" : "No");
        } else {
            scanf("%d", &a);
            printf("%d\n", sz[find(a)]);
        }
    }
}
```

## P2024 食物链
[传送门](https://www.luogu.com.cn/problem/P2024)

扩展域并查集：
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 50010;
// x是同类域, x + n是猎物域, x + 2n是天敌域
int p[3 * N], n, m, ans;

inline int find(int x) {
    if (x != p[x])  p[x] = find(p[x]);
    return p[x];
}

void merge(int x, int y) {
    x = find(x), y = find(y);
    if (x != y) p[x] = y;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= 3 * n; ++ i)   p[i] = i;
    while (m -- ) {
        int op, x, y;
        scanf("%d%d%d", &op, &x, &y);
        if (x > n || y > n) ++ ans;
        else if (op == 1) { // x,y是同类
            // 如果x在y的猎物域，或x在y的天敌域，则是假话
            if (find(x) == find(y + n) || find(x) == find(y + 2 * n)) {
                ++ ans;
            } else {    // 是真话，那么合并同类集合
                merge(x, y);
                merge(x + n, y + n);
                merge(x + 2 * n, y + 2 * n);
            }
        } else {    // x吃y
            // 如果x和y在同类域，或者x在y的猎物域，则是假话
            if (find(x) == find(y) || find(x) == find(y + n)) {
                ++ ans;
            } else {    // 是真话，那么合并同类集合
                merge(x, y + 2 * n);
                merge(x + n, y);
                merge(x + 2 * n, y + n);
            }
        }
    }
    printf("%d\n", ans);
}
```


带权并查集：
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 50010;
int p[N], dep[N], n, m, ans;

int find(int x) {
    if (x != p[x]) {
        int fa = find(p[x]);    // 找到x所在集合的代表元fa
        dep[x] = (dep[x] + dep[p[x]]) % 3;
        p[x] = fa;
    }
    return p[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++ i)  p[i] = i, dep[i] = 0;
    while (m -- ) {
        int c, x, y;
        scanf("%d%d%d", &c, &x, &y);
        // x或y大于n,或者是x吃y,并且x==y,即同类吃同类  则为假话
        if (x > n || y > n || (c == 2 && x == y)) {
            ++ ans;
        } else {
            int a = find(x), b = find(y);
            if (a == b) {   // 如果集合号相同,说明x和y在同一个集合中,那么不需要合并
                if ((dep[x] - dep[y] + 3) % 3 != c - 1)
                    ++ ans ;
            } else {    // 否则说明集合号不同,说明x和y不在同一个集合中,那么就需要进行合并操作了
                p[a] = b;
                dep[a] = (dep[y] - dep[x] + 3 + c - 1) % 3;
            }
        }
    }
    printf("%d\n", ans);
}
```

## P1892 团伙
[传送门](https://www.luogu.com.cn/problem/P1892)
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 2010;
int p[N], n, m, ans;

int find(int x) {
    if (x != p[x])  p[x] = find(p[x]);
    return p[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= 2 * n; ++ i)   p[i] = i;
    
    while (m -- ) {
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        if (*op == 'F') {
            p[find(a)] = find(b);
        } else {
            p[find(a + n)] = find(b);
            p[find(b + n)] = find(a);
        }
    }
    
    for (int i = 1; i <= n; ++ i)
        if (p[i] == i)
            ++ ans;
    printf("%d\n", ans);
}
```

## P1621 集合
[传送门](https://www.luogu.com.cn/problem/P1621)
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int p[N], a, b, P, ans;
bool st[N];

int find(int x) {
    if (x != p[x])
        p[x] = find(p[x]);
    return p[x];
}

void get_primes(int n) {
    for (int i = 2; i <= n; ++ i) {
        if (!st[i]) {
            if (i >= P) {
                for (int j = 2 * i; j <= n; j += i) {
                    st[j] = true;
                    int x = find(j), y = find(j - i);
                    if (j - i >= a && x != y) {
                        p[x] = y;
                        -- ans;
                    }
                }
            } else {
                for (int j = 2 * i; j <= n; j += i)
                    st[j] = true;
            }
        }
    }
}

int main() {
    scanf("%d%d%d", &a, &b, &P);
    for (int i = 1; i <= b; ++ i)   p[i] = i;
    ans = b - a + 1;
    get_primes(b);
    printf("%d\n", ans);
    return 0;
}
```

## P2078 朋友
[传送门](https://www.yuque.com/camellia_/zm0aqy/byu2xvp2xsg9r35h#ufa4i)
```C++
#include<bits/stdc++.h>
using namespace std;
const int N = 20010;
int n, m, Q1, Q2, boy, girl, p[N];

int find(int x) {
    if (x != p[x]) p[x] = find(p[x]);
    return p[x];
}

int main() {
    scanf("%d%d%d%d", &n, &m, &Q1, &Q2);
    for (int i = 1; i <= n + m; ++ i)   p[i] = i;
    while (Q1 -- ) {
        int a, b;
        scanf("%d%d", &a, &b);
        a = find(a), b = find(b);
        if (a != b) p[a] = b;
    }

    while (Q2 -- ) {
        int a, b;
        scanf("%d%d", &a, &b);
        a *= -1, b *= -1;
        a = find(a + n), b = find(b + n);
        if (a != b) p[a] = b;
    }

    int x = find(1);    // 小明是1号，这是根
    for (int i = 1; i <= n; ++ i)
        if (find(i) == x)
            ++ boy;

    int y = find(n + 1);    // 小红是n+1号，这是根
    for (int i = n + 1; i <= n + m; ++ i)
        if (find(i) == y)
            ++ girl;
    
    printf("%d", min(boy, girl));
}
```

## P1111 修复公路
[传送门](https://www.luogu.com.cn/problem/P1111)
```C++
#include<bits/stdc++.h>
using namespace std;
const int N = 1010, M = 1e5 + 10;
struct Edge {
    int x, y, t;
    bool operator < (const Edge& w) const {
        return t < w.t;
    }
} a[M];
int p[N], n, m;

inline int find(int x) {
    if (x != p[x])  p[x] = find(p[x]);
    return p[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++ i)   p[i] = i;
    for (int i = 1; i <= m; ++ i) {
        scanf("%d%d%d", &a[i].x, &a[i].y, &a[i].t);
    }
    sort(a + 1, a + 1 + m);

    for (int i = 1; i <= m; ++ i) {
        int x = find(a[i].x), y = find(a[i].y);
        if (x != y) {
            p[x] = y;
            -- n;
        }
        if (n == 1) {
            printf("%d\n", a[i].t);
            return 0;
        }
    }

    puts("-1");
}
```

## P2814 家谱
[传送门](https://www.yuque.com/camellia_/zm0aqy/nsigo4m5ehg34ot7)
```C++
#include<bits/stdc++.h>
using namespace std;
map<string, string> p;    // 第一个是该结点 第二个的该节点所在集合的根节点

string find(string x) {
    if (x != p[x])  p[x] = find(p[x]);
    return p[x];
}

int main() {
    string s, f; // f是记录父亲的名字
    char c;
    cin >> c;
    while (c != '$') {
        cin >> s;
        if (c == '#') {
            f = s;
            if (p[s] == "") p[s] = s;
        } else if (c == '+') {
            p[s] = f;
        } else {
            cout << s << ' ' << find(s) << endl;
        }
        cin >> c;
    }
    return 0;
}
```

## P1197 星球大战
[传送门](https://www.luogu.com.cn/problem/P1197)
```C++
#include<bits/stdc++.h>
using namespace std;
const int N = 4e5 + 10, M = 2 * N;
int h[N], e[M], ne[M], idx;
int p[N], ans[N], broken[N], n, m, k;
bool st[N];

void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

inline int find(int x) {
    if (x != p[x])  p[x] = find(p[x]);
    return p[x];
}

void merge(int a, int b) {
    a = find(a), b = find(b);
    if (a != b) p[a] = b;
}

int main() {
    memset(h, -1, sizeof h);
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++ i)   p[i] = i;
    while (m -- ) { // 构建原图
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }

    scanf("%d", &k);
    for (int i = 0; i < k; ++ i) {  // 构建标记图
        scanf("%d", &broken[i]);
        st[broken[i]] = true;
    }

    int tot = n - k;
    for (int i = 0; i < idx; ++ i) {    // 遍历标记图，不考虑摧毁点，然后进行并查集合并
        int a = e[i], b = e[i ^ 1];
        if (!st[a] && !st[b] && find(a) != find(b)) {
            -- tot;
            merge(a, b);
        }
    }

    ans[k] = tot;
    for (int i = k - 1; i >= 0; -- i) { // 逆序重建
        int u = broken[i];
        st[u] = false;
        ++ tot;
        for (int j = h[u]; ~j; j = ne[j]) {
            int v = e[j];
            if (!st[v] && find(u) != find(v)) {
                -- tot;
                merge(u, v);
            }
        }
        ans[i] = tot;
    }

    for (int i = 0; i <= k; ++ i)   printf("%d\n", ans[i]);
}
```
