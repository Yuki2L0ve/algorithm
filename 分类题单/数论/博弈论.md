# HDU1846 Brave Game
[传送门](https://acm.hdu.edu.cn/showproblem.php?pid=1846)

我们可以先打表找规律，下面是使用SG函数来打表找规律：

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int f[N], n, m;

int dfs(int x) {
    if (~f[x]) return f[x];

    unordered_set<int> S;
    for (int i = 1; i <= m; ++ i)
        if (x >= i)
            S.insert(dfs(x - i));

    for (int i = 0; ; ++ i)
        if (!S.count(i))
            return f[x] = i;
}

int main() {
    memset(f, -1, sizeof f);
    n = 50, m = 6;
    for (int i = 0; i <= n; ++ i) {
        printf("SG[%d] = %d\n", i, dfs(i));
    }
}
```

![image](https://github.com/user-attachments/assets/2d0473dc-3c4f-4dd6-9a97-2b9e0d1c5e88)




```C++
#include <bits/stdc++.h>
using namespace std;
int T, n, m;

int main() {
    scanf("%d", &T);
    while (T -- ) {
        scanf("%d%d", &n, &m);
        puts(n % (m + 1) ? "first" : "second");
    }
}
```

上面是只有一堆石子的巴什博弈，那么如果是有两堆石子呢？

![image](https://github.com/user-attachments/assets/400aa936-271f-4c79-8c9d-3e49c8055f22)

下面是使用SG函数来打表找规律：

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int f[N], a, b, m;

int dfs(int x) {
    if (~f[x]) return f[x];

    unordered_set<int> S;
    for (int i = 1; i <= m; ++ i)
        if (x >= i)
            S.insert(dfs(x - i));

    for (int i = 0; ; ++ i)
        if (!S.count(i))
            return f[x] = i;
}

int main() {
    memset(f, -1, sizeof f);
    a = 50, b = 60, m = 3;
    for (int i = 0; i <= max(a, b); ++ i) {
        printf("SG[%d] = %d\n", i, dfs(i));
    }
}
```

![image](https://github.com/user-attachments/assets/edbd32d8-a9d6-4372-9f1b-39036aeea3d7)

所以答案就是：
```C++
return a % (m + 1) != b % (m + 1) ? "先手" : "后手";
```

