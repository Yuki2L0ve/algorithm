# HDU1846 Brave Game
[传送门](https://acm.hdu.edu.cn/showproblem.php?pid=1846)

我们可以先打表找规律，下面是使用SG函数来打表找规律：

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int f[N], n, m;

int dfs(int x) {
    if (~f[x]) return f[x];

    unordered_set<int> S;
    for (int i = 1; i <= m; ++ i)
        if (x >= i)
            S.insert(dfs(x - i));

    for (int i = 0; ; ++ i)
        if (!S.count(i))
            return f[x] = i;
}

int main() {
    memset(f, -1, sizeof f);
    n = 50, m = 6;
    for (int i = 0; i <= n; ++ i) {
        printf("SG[%d] = %d\n", i, dfs(i));
    }
}
```

![image](https://github.com/user-attachments/assets/2d0473dc-3c4f-4dd6-9a97-2b9e0d1c5e88)




```C++
#include <bits/stdc++.h>
using namespace std;
int T, n, m;

int main() {
    scanf("%d", &T);
    while (T -- ) {
        scanf("%d%d", &n, &m);
        puts(n % (m + 1) ? "first" : "second");
    }
}
```

上面是只有一堆石子的巴什博弈，那么如果是有两堆石子呢？

![image](https://github.com/user-attachments/assets/400aa936-271f-4c79-8c9d-3e49c8055f22)

下面是使用SG函数来打表找规律：

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int f[N], a, b, m;

int dfs(int x) {
    if (~f[x]) return f[x];

    unordered_set<int> S;
    for (int i = 1; i <= m; ++ i)
        if (x >= i)
            S.insert(dfs(x - i));

    for (int i = 0; ; ++ i)
        if (!S.count(i))
            return f[x] = i;
}

int main() {
    memset(f, -1, sizeof f);
    a = 50, b = 60, m = 3;
    for (int i = 0; i <= max(a, b); ++ i) {
        printf("SG[%d] = %d\n", i, dfs(i));
    }
}
```

![image](https://github.com/user-attachments/assets/edbd32d8-a9d6-4372-9f1b-39036aeea3d7)

所以答案就是：
```C++
return a % (m + 1) != b % (m + 1) ? "先手" : "后手";
```

# P2197 Nim游戏
[传送门](https://www.luogu.com.cn/problem/P2197)

我们使用SG函数打表找规律：

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int a[N], f[N], n;

int dfs(int x) {
    if (~f[x]) return f[x];

    unordered_set<int> S;
    for (int i = 1; i <= x; ++ i)
        if (x >= i)
            S.insert(dfs(x - i));

    for (int i = 0; ; ++ i)
        if (!S.count(i))
            return f[x] = i;
}

int main() {
    memset(f, -1, sizeof f);
    n = 50;
    for (int i = 0; i <= n; ++ i) {
        printf("SG(%d) = %d\n", i, dfs(i));
    }
}
```

![image](https://github.com/user-attachments/assets/2f5b369a-5874-4b8b-a003-453a90b95ad1)


```C++
#include <bits/stdc++.h>
using namespace std;
int T, n;

int main() {
    scanf("%d", &T);
    while (T -- ) {
        scanf("%d", &n);
        int ans = 0;
        for (int i = 0; i < n; ++ i) {
            int x;
            scanf("%d", &x);
            ans ^= x;
        }
        puts(ans ? "Yes" : "No");
    }
}
```

# AcWing892 台阶-Nim游戏
[传送门](https://www.acwing.com/problem/content/894/)


我们使用SG函数打表找规律：

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10; // 设置一个足够大的值以适应问题
int a[N], f[N], n;

int dfs(int x) {	// x枚举的是第x级台阶，而不是这个台阶上的石子个数
    if (~f[x]) return f[x];

    unordered_set<int> S;
    for (int i = 1; i <= a[x]; ++ i) // 从第x级台阶可以取1至a[x]个石子
        if (x + 1 < n) // 只有当x不是最后一级台阶时
            S.insert(dfs(x + 1)); // 计算将石子移到下一级后的SG值

    for (int i = 0; ; ++ i)
        if (!S.count(i))
            return f[x] = i; // 找到最小的没有出现的SG值
}

int main() {
    memset(f, -1, sizeof f);
    scanf("%d", &n);
    for (int i = 1; i <= n; ++ i)   scanf("%d", &a[i]);
    for (int i = 1; i < n; ++ i) {
        printf("SG(%d) = %d\n", i, dfs(i));
    }
}
```

![image](https://github.com/user-attachments/assets/3bd725ae-13bd-4058-ba8a-d897d9aa6ded)

```C++
#include <bits/stdc++.h>
using namespace std;
using LL = long long ;

int main() {
    int n, x;
    scanf("%d", &n);
    LL ans = 0;
    for (int i = 1; i <= n; ++ i) {
        scanf("%d", &x);
        if (i & 1)  ans ^= x;
    }
    puts(ans ? "Yes" : "No");
}
```

# AcWing894. 拆分-Nim游戏
[传送门](https://www.yuque.com/camellia_/zm0aqy/cwoyk8wc3gs7t0q0#pgc7F)
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
int f[N], n, ans;

int dfs(int x) {
    if (~f[x])  return f[x];
    
    unordered_set<int> S;
    for (int i = 0; i < x; ++ i)
        for (int j = 0; j <= i; ++ j)
            S.insert(dfs(i) ^ dfs(j));
    
    for (int i = 0; ; ++ i)
        if (!S.count(i))
            return f[x] = i;
}

int main() {
    memset(f, -1, sizeof f);
    scanf("%d", &n);
    while (n -- ) {
        int x;
        scanf("%d", &x);
        ans ^= dfs(x);
    }
    puts(ans ? "Yes" : "No");
}
```

# P4018 Roy&October之取石子
[传送门](https://www.luogu.com.cn/problem/P4018)
```C++
#include <bits/stdc++.h>
using namespace std;
int n, T;

int main() {
    scanf("%d", &T);
    while (T -- ) {
        scanf("%d", &n);
        puts(n % 6 ? "October wins!" : "Roy wins!");
    }
}
```

# P4279 小约翰的游戏
[传送门](https://www.luogu.com.cn/problem/P4279)
```C++
#include <bits/stdc++.h>
using namespace std;
int n, T, x;

int main() {
    scanf("%d", &T);
    while (T -- ) {
        scanf("%d", &n);
        int ans = 0, sum = 0;
        for (int i = 0; i < n; ++ i) {
            scanf("%d", &x);
            ans ^= x;
            sum += x;
        }
        // 首先考虑最简单的情况,所有石子数都为1,那么奇数堆石子为必败,偶数为必胜
        if (sum == n) {
            puts(n & 1 ? "Brother" : "John");
        } else {
            puts(ans ? "John" : "Brother");
        }
    }
}
```
