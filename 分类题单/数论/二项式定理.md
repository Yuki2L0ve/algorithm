![image](https://github.com/user-attachments/assets/f14b3299-a678-4ea1-9004-e13a327868c8)
![image](https://github.com/user-attachments/assets/9afba2b5-0722-492f-ae35-ee8c3024db80)

需要用到的算法模板

```C++
// 快速幂
int qmi(int a, int b) {
    int ans = 1;
    while (b) {
        if (b & 1) ans = ans * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return ans;
}
```

```C++
// 求组合数
void init(int n) {
    fac[0] = 1;
    for (int i = 1; i <= n; ++ i) {  // 阶乘
        fac[i] = fac[i - 1] * i % MOD;
    }
    
    inv[n] = qmi(fac[n], MOD - 2);
    for (int i = n - 1; i >= 0; -- i) {  // 阶乘逆元
        inv[i] = inv[i + 1] * (i + 1) % MOD;
    }
}

LL C(int n, int m) {
    return fac[n] * inv[m] % MOD * inv[n - m] % MOD;
}
```



# P5732 杨辉三角
[传送门](https://www.luogu.com.cn/problem/P5732)
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 25;
int f[N][N], n;

int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; ++ i) {
        for (int j = 0; j <= i; ++ j) {
            if (j == 0 || j == i) {
                f[i][j] = 1;
            } else {
                f[i][j] = f[i - 1][j - 1] + f[i - 1][j];
            }
            printf("%d ", f[i][j]);
        }
        puts("");
    }
}
```
