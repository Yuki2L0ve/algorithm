# LC3 无重复字符的最长子串
[传送门](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> mp;
        int ans = 0;
        for (int l = 0, r = 0; r < s.size(); ++ r) {
            ++ mp[s[r]];
            while (mp[s[r]] > 1) {
                -- mp[s[l ++ ]];
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC1695. 删除子数组的最大得分
[传送门](https://leetcode.cn/problems/maximum-erasure-value/description/?envType=problem-list-v2&envId=7NLUuUun)
```C++
class Solution {
public:
    int maximumUniqueSubarray(vector<int>& nums) {
        int n = nums.size(), ans = 0, s = 0;
        unordered_map<int, int> mp;
        for (int l = 0, r = 0; r < n; ++ r) {
            s += nums[r];
            ++ mp[nums[r]];
            while (mp[nums[r]] > 1) {
                -- mp[nums[l]];
                s -= nums[l ++ ];
            }
            ans = max(ans, s);
        }

        return ans;
    }
};
```

# LC2958. 最多 K 个重复元素的最长子数组
[传送门](https://leetcode.cn/problems/length-of-longest-subarray-with-at-most-k-frequency/description/?envType=problem-list-v2&envId=7NLUuUun)
```C++
class Solution {
public:
    int maxSubarrayLength(vector<int>& nums, int k) {
        int n = nums.size(), ans = 0;
        unordered_map<int, int> mp;
        for (int l = 0, r = 0; r < n; ++ r) {
            ++ mp[nums[r]];
            while (mp[nums[r]] > k) {
                -- mp[nums[l ++ ]];
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC904. 水果成篮
[传送门](https://leetcode.cn/problems/fruit-into-baskets/description/)
```C++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        unordered_map<int, int> mp;
        int n = fruits.size(), k = 2, ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            ++ mp[fruits[r]];
            while (mp.size() > k) {
                if (-- mp[fruits[l]] == 0)   mp.erase(fruits[l]);
                ++ l;
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```


# LC30 串联所有单词的子串
[传送门](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/)
```C++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> ans;
        if (s.empty())  return ans;
        int n = s.size(), m = words.size(), d = words[0].size();

        unordered_map<string, int> mp;
        for (auto&x : words)    ++ mp[x];

        for (int i = 0; i < d; ++ i) {
            unordered_map<string, int > wd;
            int cnt = 0;
            for (int l = i, r = i; r + d - 1 < n; r += d) {
                string x = s.substr(r, d);
                ++ wd[x], ++ cnt;
                while (wd[x] > mp[x]) {
                    string y = s.substr(l, d);
                    -- wd[y], -- cnt;
                    l += d;
                }
                if (cnt == m)   ans.push_back(l);
            }
        }

        return ans;
    }
};
```

# LC76 最小覆盖子串
[传送门](https://leetcode.cn/problems/minimum-window-substring/)
```C++
class Solution {
public:
    string minWindow(string s, string t) {
        if (s.size() < t.size())    return "";

        unordered_map<char, int> mp;
        for (auto& c : t)   ++ mp[c];

        int start = 0, kinds = mp.size(), len = INT_MAX;
        for (int l = 0, r = 0; r < s.size(); ++ r) {
            if (-- mp[s[r]] == 0)   -- kinds;
            while (!kinds) {
                if (r - l + 1 < len) {
                    start = l;
                    len = r - l + 1;
                }
                if (++ mp[s[l ++ ]] > 0)    ++ kinds;
            }
        }

        return len == INT_MAX ? "" : s.substr(start, len);
    }
};
```

# 面试题 17.18. 最短超串
[传送门](https://leetcode.cn/problems/shortest-supersequence-lcci/?envType=problem-list-v2&envId=RIpZHMIu)
```C++
class Solution {
public:
    vector<int> shortestSeq(vector<int>& big, vector<int>& small) {
        if (big.size() < small.size())  return {};

        unordered_map<int, int> mp;
        for (auto& x : small)   ++ mp[x];

        int n = big.size(), kinds = mp.size(), len = INT_MAX, sl, sr;
        for (int l = 0, r = 0; r < n; ++ r) {
            if (-- mp[big[r]] == 0) -- kinds;
            while (!kinds) {
                if (r - l + 1 < len) {
                    len = r - l + 1;
                    sl = l, sr = r;
                }
                if (++ mp[big[l ++ ]] > 0)  ++ kinds;
            }
        }

        if (len == INT_MAX) return {};
        return {sl, sr};
    }
};
```

# LC159. 至多包含两个不同字符的最长子串
[传送门](https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/)
```C++
class Solution {
public:
    int lengthOfLongestSubstringTwoDistinct(string s) {
        unordered_map<char, int> mp;
        int n = s.size(), ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            ++ mp[s[r]];
            while (mp.size() > 2) {
                if (-- mp[s[l]] == 0)   mp.erase(s[l]);
                ++ l;
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC340 至多包含 K 个不同字符的最长子串
[传送门](https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/)
```C++
class Solution {
public:
    int lengthOfLongestSubstringKDistinct(string s, int k) {
        unordered_map<char, int> mp;
        int n = s.size(), ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            ++ mp[s[r]];
            while (mp.size() > k) {
                if (-- mp[s[l]] == 0)   mp.erase(s[l]);
                ++ l;
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC209 长度最小的子数组
[传送门](https://leetcode.cn/problems/minimum-size-subarray-sum/)
```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size(), s = 0, ans = INT_MAX;

        for (int l = 0, r = 0; r < n; ++ r) {
            s += nums[r];
            while (s >= target) {
                ans = min(ans, r - l + 1);
                s -= nums[l ++ ];
            }
        }

        return ans == INT_MAX ? 0 : ans;
    }
};
```

# LC395 至少有 K 个重复字符的最长子串
[传送门](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/)
```C++
class Solution {
public:
    int longestSubstring(string s, int k) {
        int n = s.size(), ans = 0;
        // 滑窗中字母种类个数恰好为d种
        for (int d = 1; d <= 26; ++ d) {
            // 哈希表mp用来统计在当前窗口中每个字符的出现次数   (字符, 该字符出现次数)
            unordered_map<char, int> mp;
            // kinds用来统计当前窗口中有多少种不同的字符, 比如aaabb就是有2种不同的字符
            // tot用来统计当前窗口中有多少种字符的出现次数>=k, 比如ababbcc有三种字符出现次数都>=2
            int kinds = 0, tot = 0;
            for (int l = 0, r = 0; r < n; ++ r) {
                // 说明出现了一种新的字符
                if (++ mp[s[r]] == 1) ++ kinds;
                // 说明这种字符的出现次数等于k
                if (mp[s[r]] == k)    ++ tot;
                // 当窗口中的不同字符种类数kinds超过了当前窗口中限定的字符种类数d时
                while (kinds > d) {
                    if (-- mp[s[l]] == 0) --kinds;
                    if (mp[s[l]] == k - 1)    -- tot;
                    ++ l;
                }
                // 比如ababb，此时kinds=2, tot=2
                if (kinds == tot)   ans = max(ans, r - l + 1);
            }
        }
        return ans;
    }
};
```

# LC1763. 最长的美好子字符串
[传送门](https://leetcode.cn/problems/longest-nice-substring/description/?envType=problem-list-v2&envId=7NLUuUun)
```C++
class Solution {
public:
    string longestNiceSubstring(string s) {
        string ans;
        for (int d = 1; d <= 26; ++ d) {
            // low和high分别用于记录小写字符和大写字符的出现次数
            vector<int> low(26), high(26);
            // kinds表示当前窗口内的字符种类数
            // tot表示当前窗口内的字符对数（即同时包含小写和大写字符的字符种类数）
            int n = s.size(), kinds = 0, tot = 0; 
            for (int l = 0, r = 0; r < n; ++ r) {
                int idx = tolower(s[r]) - 'a';
                if (isupper(s[r])) {
                    // 如果当前字符是大写字符，则增加high[idx]的计数，并检查是否形成新的字符对
                    ++ high[idx];
                    if (high[idx] == 1 && low[idx] > 0) ++ tot;
                } else {
                    // 如果当前字符是小写字符，则增加 low[idx] 的计数，并检查是否形成新的字符对
                    ++ low[idx];
                    if (low[idx] == 1 && high[idx] > 0) ++ tot;
                }
                
                // 如果当前字符对的数量为 1（即当前加入的那个）
                if (low[idx] + high[idx] == 1)  ++ kinds;

                while (kinds > d) { // 始终保证窗口内字符种数==d
                    int lidx= tolower(s[l]) - 'a';
                    if (isupper(s[l])) {
                        // 如果删除的字符是大写字符，则减少high[lidx]的计数，并检查是否删除了一对字符
                        -- high[lidx];
                        if (!high[lidx] && low[lidx] > 0)   -- tot;
                    } else {
                        // 如果删除的字符是小写字符，则减少 low[lidx] 的计数，并检查是否删除了一对字符
                        -- low[lidx];
                        if (!low[lidx] && high[lidx] > 0)   -- tot;
                    }

                    // 如果删除的字符对的数量为0，则减少字符种类数
                    if (low[lidx] + high[lidx] == 0)    -- kinds;

                    ++ l; 
                }

                // 如果当前窗口内的字符对数tot等于字符种类数kinds，则表示当前窗口是一个美好子字符串。
                if (tot == kinds) {
                    string t = s.substr(l, r - l + 1);
                    if (t.size() > ans.size()) {
                        ans = t;
                    }
                }
            }
        }

        return ans;
    }
};
```


# LC424 替换后的最长重复字符
[传送门](https://leetcode.cn/problems/longest-repeating-character-replacement/description/)
```C++
class Solution {
public:
    int characterReplacement(string s, int k) {
        unordered_map<char, int> mp;
        int n = s.size(), ans = 0, cnt = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            ++ mp[s[r]];
            cnt = max(cnt, mp[s[r]]);
            while (r - l + 1 - cnt > k) {
                -- mp[s[l ++ ]];
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC1004. 最大连续1的个数 III
[传送门](https://leetcode.cn/problems/max-consecutive-ones-iii/description/)
```C++
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int n = nums.size(), zeros = 0, ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            zeros += nums[r] == 0;
            while (zeros > k) {
                zeros -= nums[l] == 0;
                ++ l;
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC487. 最大连续1的个数 II
[传送门](https://leetcode.cn/problems/max-consecutive-ones-ii/description/)
```C++
class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
        int n = nums.size(), k = 1, zeros = 0, ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            zeros += nums[r] == 0;
            while (zeros > k) {
                zeros -= nums[l] == 0;
                ++ l;
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

```C++
class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size(), k = 1, zeros = 0, ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            zeros += nums[r] == 0;
            while (zeros > k) {
                zeros -= nums[l] == 0;
                ++ l;
            }
            ans = max(ans, r - l);
        }
        return ans;
    }
};
```


# LC713. 乘积小于 K 的子数组
[传送门](https://leetcode.cn/problems/subarray-product-less-than-k/description/)
```C++
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        int n = nums.size(), s = 1, ans = 0;
        if (k <= 1 || !n)   return 0;

        for (int l = 0, r = 0; r < n; ++ r) {
            s *= nums[r];
            while (s >= k) {
                s /= nums[l ++ ];
            }
            ans += r - l + 1;
        }

        return ans;
    }
};
```

# LC795. 区间子数组个数
[传送门](https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/description/)
```C++
class Solution {
public:
    int solve(vector<int>& nums, int k) {
        int ans = 0, cnt = 0;
        for (auto& x : nums) {
            if (x <= k) ++ cnt;
            else    cnt = 0;
            ans += cnt;
        }
        return ans;
    }

    int numSubarrayBoundedMax(vector<int>& nums, int left, int right) {
        return solve(nums, right) - solve(nums, left - 1);
    }
};
```

# LC930. 和相同的二元子数组
[传送门](https://leetcode.cn/problems/binary-subarrays-with-sum/description/)
```C++
class Solution {
public:
    int atMostK(vector<int>& nums, int k) {
        if (k < 0)  return 0;
        int n = nums.size(), ans = 0, s = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            s += nums[r];
            while (s > k) {
                s -= nums[l ++ ];
            }
            ans += r - l + 1;
        }
        return ans;
    }

    int numSubarraysWithSum(vector<int>& nums, int goal) {
        return atMostK(nums, goal) - atMostK(nums, goal - 1);
    }
};
```

# LC992. K 个不同整数的子数组
[传送门](https://leetcode.cn/problems/subarrays-with-k-different-integers/description/)
```C++
class Solution {
public:
    int solve(vector<int>& nums, int k) {
        unordered_map<int, int> mp;
        int n = nums.size(), ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            ++ mp[nums[r]];
            while (mp.size() > k) {
                if (-- mp[nums[l]] == 0)    mp.erase(nums[l]);
                ++ l;
            }
            ans += r - l + 1;
        }
        return ans;
    }

    int subarraysWithKDistinct(vector<int>& nums, int k) {
        return solve(nums, k) - solve(nums, k - 1);
    }
};
```

# LC1248. 统计「优美子数组」
[传送门](https://leetcode.cn/problems/count-number-of-nice-subarrays/description/)
```C++
class Solution {
public:
    int solve(vector<int>& nums, int k) {
        int n = nums.size(), odds = 0, ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            odds += (nums[r] & 1);
            while (odds > k) {
                odds -= (nums[l] & 1);
                ++ l;
            }
            ans += r - l + 1;
        }
        return ans;
    }

    int numberOfSubarrays(vector<int>& nums, int k) {
        return solve(nums, k) - solve(nums, k - 1);
    }
};
```


# LC1234. 替换子串得到平衡字符串
[传送门](https://leetcode.cn/problems/replace-the-substring-for-balanced-string/description/)
```C++
class Solution {
public:
    int balancedString(string s) {
        int n = s.size(), m = n / 4, ans = INT_MAX;

        unordered_map<char, int> mp;
        for (auto& c : s)   ++ mp[c];
        if (mp['Q'] == m && mp['W'] == m && mp['E'] == m && mp['R'] == m) {
            return 0;
        }

        for (int l = 0, r = 0; r < n; ++ r) {
            -- mp[s[r]];
            while (mp['Q'] <= m && mp['W'] <= m && mp['E'] <= m && mp['R'] <= m) {
                ans = min(ans, r - l + 1);
                ++ mp[s[l ++ ]];
            }
        }

        return ans;
    }
};
```

# LC1658. 将 x 减到 0 的最小操作数
[传送门](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/description/)
```C++
class Solution {
public:
    int minOperations(vector<int>& nums, int x) {
        int target = accumulate(nums.begin(), nums.end(), 0) - x;
        if (target < 0) return -1;

        int n = nums.size(), s = 0, ans = -1;
        for (int l = 0, r = 0; r < n; ++ r) {
            s += nums[r];
            while (s > target) {
                s -= nums[l ++ ];
            }
            if (s == target)    ans = max(ans, r - l + 1);
        }

        return ans == -1 ? -1 : n - ans;
    }
};
```

# LC1438. 绝对差不超过限制的最长连续子数组
[传送门](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/description/)
```C++
class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        // a队列维护当前窗口的最大值，b队列维护当前窗口的最小值
        deque<int> a, b;

        int n = nums.size(), ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            // 维护最大值队列
            while (!a.empty() && nums[a.back()] < nums[r]) {    // 不能写成等号
                a.pop_back();
            }
            a.push_back(r);

            // 维护最小值队列
            while (!b.empty() && nums[b.back()] > nums[r]) {    // 不能写成等号
                b.pop_back();
            } 
            b.push_back(r);

            // 检查当前窗口的最大值和最小值的差是否小于等于 limit
            while (!a.empty() && !b.empty() && nums[a.front()] - nums[b.front()] > limit) {
                // 移动左边界
                if (l == a.front()) {
                    a.pop_front();
                }
                if (l == b.front()) {
                    b.pop_front();
                }
                ++ l;
            }

            // 更新最长子数组的长度
            ans = max(ans, r - l + 1);
        }

        return ans;
    }
};
```

# LC2875. 无限数组的最短子数组
[传送门](https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/description/)
```C++
class Solution {
public:
    using LL = long long ;
    int minSizeSubarray(vector<int>& nums, int target) {
        int n = nums.size();
        // 计算数组的总和
        LL totalSum = accumulate(nums.begin(), nums.end(), 0ll), s = 0;
        
        // 如果 target 大于 totalSum，我们需要考虑多个完整的 nums 数组
        int cnt = target / totalSum;
        int remainingTarget = target % totalSum;
        
        // 如果 remainingTarget 为 0，说明 target 正好是 totalSum 的整数倍
        if (remainingTarget == 0) {
            return cnt * n;
        }
        
        // 使用滑动窗口寻找最短的子数组，使得其和等于 remainingTarget
        int ans = INT_MAX;
        for (int l = 0, r = 0; r < 2 * n; ++r) {
            s += nums[r % n];
            
            // 如果当前窗口的和大于 remainingTarget，移动左边界
            while (s > remainingTarget) {
                s -= nums[l % n];
                ++ l;
            }
            
            // 如果当前窗口的和等于 remainingTarget，更新最小长度
            if (s == remainingTarget) {
                ans = min(ans, r - l + 1);
            }
        }
        
        // 返回最小长度加上完整的 nums 数组的长度
        return ans == INT_MAX ? -1 : ans + cnt * n;
    }
};
```

# LC2024. 考试的最大困扰度
[传送门](https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/description/?envType=problem-list-v2&envId=7NLUuUun)
```C++
class Solution {
public:
    int maxConsecutiveAnswers(string s, int k) {
        int n = s.size(), ans = 0, t = 0, f = 0;
        // 记录t和f的数量，如果它们而这种最小的那个都大于k，那么不满足，需要收缩窗口
        for (int l = 0, r = 0; r < n; ++ r) {
            if (s[r] == 'T')    ++ t;
            else    ++ f;
            while (min(t, f) > k) {
                if (s[l] == 'T')    -- t;
                else    -- f;
                ++ l;
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC2401. 最长优雅子数组
[传送门](https://leetcode.cn/problems/longest-nice-subarray/description/?envType=problem-list-v2&envId=7NLUuUun)
```C++
class Solution {
public:
    int longestNiceSubarray(vector<int> &nums) {
        int n = nums.size(), ans = 0, orValue = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            while (orValue & nums[r]) { // 有交集
                orValue ^= nums[l ++ ]; // 从orValue中去掉集合nums[l]
            }
            orValue |= nums[r]; // 把集合nums[r]并入orValue中
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC1838. 最高频元素的频数
[传送门](https://leetcode.cn/problems/frequency-of-the-most-frequent-element/description/?envType=problem-list-v2&envId=7NLUuUun)
```C++
class Solution {
public:
    using LL = long long ;
    int maxFrequency(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int n = nums.size(), ans = 1;

        // 计算前缀和
        vector<LL> s(n + 1);
        for (int i = 0; i < n; ++ i)    s[i + 1] = s[i] + nums[i];
        
        for (int l = 0, r = 0; r < n; ++ r) {
            // 计算将 [l, r] 区间内的所有元素变成nums[r]需要的操作次数
            LL cnt = 1ll * (r - l + 1) * nums[r] - (s[r + 1] - s[l]);
            // 如果操作次数超过k，则移动左边界l
            while (cnt > k) {
                cnt -= nums[r] - nums[l];
                ++ l;
            }
            // 更新最大频数
            ans = max(ans, r - l + 1);
        }

        return ans;
    }
};
```

# LC2968. 执行操作使频率分数最大
[传送门](https://leetcode.cn/problems/apply-operations-to-maximize-frequency-score/description/?envType=problem-list-v2&envId=7NLUuUun)
```C++
class Solution {
public:
    using LL = long long ;
    int maxFrequencyScore(vector<int> &nums, long long k) {
        int n = nums.size(), ans = 0;
        sort(nums.begin(), nums.end());

        // 求前缀和
        vector<LL> s(n + 1);
        for (int i = 0; i < n; ++ i)    s[i + 1] = s[i] + nums[i];

        // 计算将nums[l]到nums[r]都变成nums[i]所需要的操作次数
        auto get = [&](int l, int i, int r) -> LL {
            // sl: 表示将nums[l]到nums[i-1]变成nums[i]所需的代价, [l, i - 1]
            LL sl = (LL) nums[i] * (i - l) - (s[i] - s[l]);
            // sr: 表示将nums[i+1]到nums[r]变成nums[i]所需的代价, [i + 1, r]
            LL sr = s[r + 1] - s[i + 1] - (LL) nums[i] * (r - i);
            return sl + sr;
        };

        for (int l = 0, r = 0; r < n; ++ r) {
            while (get(l, (l + r) / 2, r) > k) {
                ++ l;
            }
            ans = max(ans, r - l + 1);
        }

        return ans;
    }
};
```


# LC2106. 摘水果
[传送门](https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/description/?envType=problem-list-v2&envId=7NLUuUun)
```C++
class Solution {
public:
    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {
        int n = fruits.size(), ans = 0, s = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            int pos = fruits[r][0], val = fruits[r][1];
            s += val;
            while (pos - fruits[l][0] + min(abs(startPos - fruits[l][0]), abs(pos - startPos)) > k) {
                s -= fruits[l ++ ][1];
            }
            ans = max(ans, s);
        }
        return ans;
    }
};
```

# LCLC2781. 最长合法子字符串的长度
[传送门](https://leetcode.cn/problems/length-of-the-longest-valid-substring/description/?envType=problem-list-v2&envId=7NLUuUun)
```C++
class Solution {
public:
    int longestValidSubstring(string word, vector<string>& forbidden) {
        unordered_set<string> S(forbidden.begin(), forbidden.end());
        int n = word.size(), ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            // i >= l: 确保i不会小于l指针，即确保我们检查的子串在当前窗口内
            // r - i <= 9: 子串区间[i, r]，确保我们检查的子串长度不超过10, 即r - i + 1 <= 10
            for (int i = r; i >= l && r - i <= 9; -- i) {
                if (S.count(word.substr(i, r - i + 1))) {
                    l = i + 1;
                    break;
                }
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```
# LC3134. 找出唯一性数组的中位数
[传送门](https://leetcode.cn/problems/find-the-median-of-the-uniqueness-array/?envType=problem-list-v2&envId=7NLUuUun)
```C++
class Solution {
public:
    using LL = long long ;

    bool check(vector<int>& nums, int k, LL x) {
        LL cnt = 0; 
        unordered_map<int, int> mp;
        for (int l = 0, r = 0; r < nums.size(); ++ r) {
            ++ mp[nums[r]]; 
            while (mp.size() > k) {
                if (-- mp[nums[l]] == 0)    mp.erase(nums[l]);
                ++ l;
            }
            cnt += r - l + 1; 
            if (cnt >= x) {
                return true;
            }
        }

        return false;
    };

    int medianOfUniquenessArray(vector<int>& nums) {
        int n = nums.size();
        LL x = (1ll * n * (n + 1) / 2 + 1) / 2;

        // 二分答案
        int l = 0, r = n;
        while (l < r) {
            int mid = (l + r) / 2;
            if (check(nums, mid, x)) r = mid;
            else    l = mid + 1;
        }

        return r;
    }
};
```

# LC1358. 包含所有三种字符的子字符串数目
[传送门](https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/description/?envType=problem-list-v2&envId=bDZtS7FW)
```C++
class Solution {
public:
    int numberOfSubstrings(string s) {
        unordered_map<char, int> mp;
        int n = s.size(), ans = 0, k = 3;
        for (int l = 0, r = 0; r < n; ++ r) {
            ++ mp[s[r]];
            while (mp.size() == k) {
                ans += n - r;
                if (-- mp[s[l]] == 0)   mp.erase(s[l]);
                ++ l;
            }
        }
        return ans;
    }
};
```

# LC2962. 统计最大元素出现至少 K 次的子数组
[传送门](https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times/description/?envType=problem-list-v2&envId=bDZtS7FW)
```C++
class Solution {
public:
    long long countSubarrays(vector<int>& nums, int k) {
        int n = nums.size(), cnt = 0, mx = *max_element(nums.begin(), nums.end());
        long long ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            cnt += nums[r] == mx;
            while (cnt >= k) {
                ans += n - r;
                cnt -= nums[l] == mx;
                ++ l;
            }
        }
        return ans;
    }
};
```
