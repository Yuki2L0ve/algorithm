# LC3 无重复字符的最长子串
[传送门](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> mp;
        int ans = 0, n = s.size();
        for (int l = 0, r = 0; r < n; ++ r) {
            ++ mp[s[r]];
            while (mp[s[r]] > 1) {
                -- mp[s[l ++ ]];
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC904. 水果成篮
[传送门](https://leetcode.cn/problems/fruit-into-baskets/description/)
```C++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        unordered_map<int, int> mp;
        int n = fruits.size(), k = 2, ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            ++ mp[fruits[r]];
            while (mp.size() > k) {
                if (-- mp[fruits[l]] == 0)   mp.erase(fruits[l]);
                ++ l;
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```


# LC30 串联所有单词的子串
[传送门](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/)
```C++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> ans;
        if (s.empty())  return ans;
        int n = s.size(), m = words.size(), d = words[0].size();

        unordered_map<string, int> mp;
        for (auto&x : words)    ++ mp[x];

        for (int i = 0; i < d; ++ i) {
            unordered_map<string, int > wd;
            int cnt = 0;
            for (int l = i, r = i; r + d - 1 < n; r += d) {
                string x = s.substr(r, d);
                ++ wd[x], ++ cnt;
                while (wd[x] > mp[x]) {
                    string y = s.substr(l, d);
                    -- wd[y], -- cnt;
                    l += d;
                }
                if (cnt == m)   ans.push_back(l);
            }
        }

        return ans;
    }
};
```

# LC76 最小覆盖子串
[传送门](https://leetcode.cn/problems/minimum-window-substring/)
```C++
class Solution {
public:
    string minWindow(string s, string t) {
        if (s.size() < t.size())    return "";

        unordered_map<char, int> mp;
        for (auto& c : t)   ++ mp[c];

        int start = 0, kinds = mp.size(), len = INT_MAX;
        for (int l = 0, r = 0; r < s.size(); ++ r) {
            if (-- mp[s[r]] == 0)   -- kinds;
            while (!kinds) {
                if (r - l + 1 < len) {
                    start = l;
                    len = r - l + 1;
                }
                if (++ mp[s[l ++ ]] > 0)    ++ kinds;
            }
        }

        return len == INT_MAX ? "" : s.substr(start, len);
    }
};
```

# LC159. 至多包含两个不同字符的最长子串
[传送门](https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/)
```C++
class Solution {
public:
    int lengthOfLongestSubstringTwoDistinct(string s) {
        unordered_map<char, int> mp;
        int n = s.size(), ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            ++ mp[s[r]];
            while (mp.size() > 2) {
                if (-- mp[s[l]] == 0)   mp.erase(s[l]);
                ++ l;
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC340 至多包含 K 个不同字符的最长子串
[传送门](https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/)
```C++
class Solution {
public:
    int lengthOfLongestSubstringKDistinct(string s, int k) {
        unordered_map<char, int> mp;
        int n = s.size(), ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            ++ mp[s[r]];
            while (mp.size() > k) {
                if (-- mp[s[l]] == 0)   mp.erase(s[l]);
                ++ l;
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC209 长度最小的子数组
[传送门](https://leetcode.cn/problems/minimum-size-subarray-sum/)
```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size(), s = 0, ans = INT_MAX;

        for (int l = 0, r = 0; r < n; ++ r) {
            s += nums[r];
            while (s >= target) {
                ans = min(ans, r - l + 1);
                s -= nums[l ++ ];
            }
        }

        return ans == INT_MAX ? 0 : ans;
    }
};
```

# LC395 至少有 K 个重复字符的最长子串
[传送门](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/)
```C++
class Solution {
public:
    int longestSubstring(string s, int k) {
        int n = s.size(), ans = 0;
        // 滑窗中字母种类个数恰好为d种
        for (int d = 1; d <= 26; ++ d) {
            // 哈希表mp用来统计在当前窗口中每个字符的出现次数   (字符, 该字符出现次数)
            unordered_map<char, int> mp;
            // kinds用来统计当前窗口中有多少种不同的字符, 比如aaabb就是有2种不同的字符
            // tot用来统计当前窗口中有多少种字符的出现次数>=k, 比如ababbcc有三种字符出现次数都>=2
            int kinds = 0, tot = 0;
            for (int l = 0, r = 0; r < n; ++ r) {
                // 说明出现了一种新的字符
                if (++ mp[s[r]] == 1) ++ kinds;
                // 说明这种字符的出现次数等于k
                if (mp[s[r]] == k)    ++ tot;
                // 当窗口中的不同字符种类数kinds超过了当前窗口中限定的字符种类数d时
                while (kinds > d) {
                    if (-- mp[s[l]] == 0) --kinds;
                    if (mp[s[l]] == k - 1)    -- tot;
                    ++ l;
                }
                // 比如ababb，此时kinds=2, tot=2
                if (kinds == tot)   ans = max(ans, r - l + 1);
            }
        }
        return ans;
    }
};
```

# LC424 替换后的最长重复字符
[传送门](https://leetcode.cn/problems/longest-repeating-character-replacement/description/)
```C++
class Solution {
public:
    int characterReplacement(string s, int k) {
        unordered_map<char, int> mp;
        int n = s.size(), ans = 0, cnt = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            ++ mp[s[r]];
            cnt = max(cnt, mp[s[r]]);
            while (r - l + 1 - cnt > k) {
                -- mp[s[l ++ ]];
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC1004. 最大连续1的个数 III
[传送门](https://leetcode.cn/problems/max-consecutive-ones-iii/description/)
```C++
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int n = nums.size(), zeros = 0, ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            zeros += nums[r] == 0;
            while (zeros > k) {
                zeros -= nums[l] == 0;
                ++ l;
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC487. 最大连续1的个数 II
[传送门](https://leetcode.cn/problems/max-consecutive-ones-ii/description/)
```C++
class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
        int n = nums.size(), k = 1, zeros = 0, ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            zeros += nums[r] == 0;
            while (zeros > k) {
                zeros -= nums[l] == 0;
                ++ l;
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```


# LC713. 乘积小于 K 的子数组
[传送门](https://leetcode.cn/problems/subarray-product-less-than-k/description/)
```C++
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        int n = nums.size(), s = 1, ans = 0;
        if (k <= 1 || !n)   return 0;

        for (int l = 0, r = 0; r < n; ++ r) {
            s *= nums[r];
            while (s >= k) {
                s /= nums[l ++ ];
            }
            ans += r - l + 1;
        }

        return ans;
    }
};
```

# LC795. 区间子数组个数
[传送门](https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/description/)
```C++
class Solution {
public:
    int solve(vector<int>& nums, int limit) {
        int ans = 0, cnt = 0;
        for (auto& x : nums) {
            if (x <= limit) ++ cnt;
            else    cnt = 0;
            ans += cnt;
        }
        return ans;
    }

    int numSubarrayBoundedMax(vector<int>& nums, int left, int right) {
        return solve(nums, right) - solve(nums, left - 1);
    }
};
```

# LC930. 和相同的二元子数组
[传送门](https://leetcode.cn/problems/binary-subarrays-with-sum/description/)
```C++
class Solution {
public:
    int atMostK(vector<int>& nums, int limit) {
        if (limit < 0)  return 0;
        int n = nums.size(), ans = 0, s = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            s += nums[r];
            while (s > limit) {
                s -= nums[l ++ ];
            }
            ans += r - l + 1;
        }
        return ans;
    }

    int numSubarraysWithSum(vector<int>& nums, int goal) {
        return atMostK(nums, goal) - atMostK(nums, goal - 1);
    }
};
```
