# LC3 无重复字符的最长子串
[传送门](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> mp;
        int ans = 0;
        for (int l = 0, r = 0; r < s.size(); ++ r) {
            ++ mp[s[r]];
            while (mp[s[r]] > 1) {
                -- mp[s[l ++ ]];
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC1695. 删除子数组的最大得分
[传送门](https://leetcode.cn/problems/maximum-erasure-value/description/?envType=problem-list-v2&envId=7NLUuUun)
```C++
class Solution {
public:
    int maximumUniqueSubarray(vector<int>& nums) {
        int n = nums.size(), ans = 0, s = 0;
        unordered_map<int, int> mp;
        for (int l = 0, r = 0; r < n; ++ r) {
            s += nums[r];
            ++ mp[nums[r]];
            while (mp[nums[r]] > 1) {
                -- mp[nums[l]];
                s -= nums[l ++ ];
            }
            ans = max(ans, s);
        }

        return ans;
    }
};
```

# LC2958. 最多 K 个重复元素的最长子数组
[传送门](https://leetcode.cn/problems/length-of-longest-subarray-with-at-most-k-frequency/description/?envType=problem-list-v2&envId=7NLUuUun)
```C++
class Solution {
public:
    int maxSubarrayLength(vector<int>& nums, int k) {
        int n = nums.size(), ans = 0;
        unordered_map<int, int> mp;
        for (int l = 0, r = 0; r < n; ++ r) {
            ++ mp[nums[r]];
            while (mp[nums[r]] > k) {
                -- mp[nums[l ++ ]];
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC904. 水果成篮
[传送门](https://leetcode.cn/problems/fruit-into-baskets/description/)
```C++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        unordered_map<int, int> mp;
        int n = fruits.size(), k = 2, ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            ++ mp[fruits[r]];
            while (mp.size() > k) {
                if (-- mp[fruits[l]] == 0)   mp.erase(fruits[l]);
                ++ l;
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```


# LC30 串联所有单词的子串
[传送门](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/)
```C++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> ans;
        if (s.empty())  return ans;
        int n = s.size(), m = words.size(), d = words[0].size();

        unordered_map<string, int> mp;
        for (auto&x : words)    ++ mp[x];

        for (int i = 0; i < d; ++ i) {
            unordered_map<string, int > wd;
            int cnt = 0;
            for (int l = i, r = i; r + d - 1 < n; r += d) {
                string x = s.substr(r, d);
                ++ wd[x], ++ cnt;
                while (wd[x] > mp[x]) {
                    string y = s.substr(l, d);
                    -- wd[y], -- cnt;
                    l += d;
                }
                if (cnt == m)   ans.push_back(l);
            }
        }

        return ans;
    }
};
```

# LC76 最小覆盖子串
[传送门](https://leetcode.cn/problems/minimum-window-substring/)
```C++
class Solution {
public:
    string minWindow(string s, string t) {
        if (s.size() < t.size())    return "";

        unordered_map<char, int> mp;
        for (auto& c : t)   ++ mp[c];

        int start = 0, kinds = mp.size(), len = INT_MAX;
        for (int l = 0, r = 0; r < s.size(); ++ r) {
            if (-- mp[s[r]] == 0)   -- kinds;
            while (!kinds) {
                if (r - l + 1 < len) {
                    start = l;
                    len = r - l + 1;
                }
                if (++ mp[s[l ++ ]] > 0)    ++ kinds;
            }
        }

        return len == INT_MAX ? "" : s.substr(start, len);
    }
};
```

# LC159. 至多包含两个不同字符的最长子串
[传送门](https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/)
```C++
class Solution {
public:
    int lengthOfLongestSubstringTwoDistinct(string s) {
        unordered_map<char, int> mp;
        int n = s.size(), ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            ++ mp[s[r]];
            while (mp.size() > 2) {
                if (-- mp[s[l]] == 0)   mp.erase(s[l]);
                ++ l;
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC340 至多包含 K 个不同字符的最长子串
[传送门](https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/)
```C++
class Solution {
public:
    int lengthOfLongestSubstringKDistinct(string s, int k) {
        unordered_map<char, int> mp;
        int n = s.size(), ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            ++ mp[s[r]];
            while (mp.size() > k) {
                if (-- mp[s[l]] == 0)   mp.erase(s[l]);
                ++ l;
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC209 长度最小的子数组
[传送门](https://leetcode.cn/problems/minimum-size-subarray-sum/)
```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size(), s = 0, ans = INT_MAX;

        for (int l = 0, r = 0; r < n; ++ r) {
            s += nums[r];
            while (s >= target) {
                ans = min(ans, r - l + 1);
                s -= nums[l ++ ];
            }
        }

        return ans == INT_MAX ? 0 : ans;
    }
};
```

# LC395 至少有 K 个重复字符的最长子串
[传送门](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/)
```C++
class Solution {
public:
    int longestSubstring(string s, int k) {
        int n = s.size(), ans = 0;
        // 滑窗中字母种类个数恰好为d种
        for (int d = 1; d <= 26; ++ d) {
            // 哈希表mp用来统计在当前窗口中每个字符的出现次数   (字符, 该字符出现次数)
            unordered_map<char, int> mp;
            // kinds用来统计当前窗口中有多少种不同的字符, 比如aaabb就是有2种不同的字符
            // tot用来统计当前窗口中有多少种字符的出现次数>=k, 比如ababbcc有三种字符出现次数都>=2
            int kinds = 0, tot = 0;
            for (int l = 0, r = 0; r < n; ++ r) {
                // 说明出现了一种新的字符
                if (++ mp[s[r]] == 1) ++ kinds;
                // 说明这种字符的出现次数等于k
                if (mp[s[r]] == k)    ++ tot;
                // 当窗口中的不同字符种类数kinds超过了当前窗口中限定的字符种类数d时
                while (kinds > d) {
                    if (-- mp[s[l]] == 0) --kinds;
                    if (mp[s[l]] == k - 1)    -- tot;
                    ++ l;
                }
                // 比如ababb，此时kinds=2, tot=2
                if (kinds == tot)   ans = max(ans, r - l + 1);
            }
        }
        return ans;
    }
};
```

# LC424 替换后的最长重复字符
[传送门](https://leetcode.cn/problems/longest-repeating-character-replacement/description/)
```C++
class Solution {
public:
    int characterReplacement(string s, int k) {
        unordered_map<char, int> mp;
        int n = s.size(), ans = 0, cnt = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            ++ mp[s[r]];
            cnt = max(cnt, mp[s[r]]);
            while (r - l + 1 - cnt > k) {
                -- mp[s[l ++ ]];
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC1004. 最大连续1的个数 III
[传送门](https://leetcode.cn/problems/max-consecutive-ones-iii/description/)
```C++
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int n = nums.size(), zeros = 0, ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            zeros += nums[r] == 0;
            while (zeros > k) {
                zeros -= nums[l] == 0;
                ++ l;
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC487. 最大连续1的个数 II
[传送门](https://leetcode.cn/problems/max-consecutive-ones-ii/description/)
```C++
class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
        int n = nums.size(), k = 1, zeros = 0, ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            zeros += nums[r] == 0;
            while (zeros > k) {
                zeros -= nums[l] == 0;
                ++ l;
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

```C++
class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size(), k = 1, zeros = 0, ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            zeros += nums[r] == 0;
            while (zeros > k) {
                zeros -= nums[l] == 0;
                ++ l;
            }
            ans = max(ans, r - l);
        }
        return ans;
    }
};
```


# LC713. 乘积小于 K 的子数组
[传送门](https://leetcode.cn/problems/subarray-product-less-than-k/description/)
```C++
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        int n = nums.size(), s = 1, ans = 0;
        if (k <= 1 || !n)   return 0;

        for (int l = 0, r = 0; r < n; ++ r) {
            s *= nums[r];
            while (s >= k) {
                s /= nums[l ++ ];
            }
            ans += r - l + 1;
        }

        return ans;
    }
};
```

# LC795. 区间子数组个数
[传送门](https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/description/)
```C++
class Solution {
public:
    int solve(vector<int>& nums, int k) {
        int ans = 0, cnt = 0;
        for (auto& x : nums) {
            if (x <= k) ++ cnt;
            else    cnt = 0;
            ans += cnt;
        }
        return ans;
    }

    int numSubarrayBoundedMax(vector<int>& nums, int left, int right) {
        return solve(nums, right) - solve(nums, left - 1);
    }
};
```

# LC930. 和相同的二元子数组
[传送门](https://leetcode.cn/problems/binary-subarrays-with-sum/description/)
```C++
class Solution {
public:
    int atMostK(vector<int>& nums, int k) {
        if (k < 0)  return 0;
        int n = nums.size(), ans = 0, s = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            s += nums[r];
            while (s > k) {
                s -= nums[l ++ ];
            }
            ans += r - l + 1;
        }
        return ans;
    }

    int numSubarraysWithSum(vector<int>& nums, int goal) {
        return atMostK(nums, goal) - atMostK(nums, goal - 1);
    }
};
```

# LC992. K 个不同整数的子数组
[传送门](https://leetcode.cn/problems/subarrays-with-k-different-integers/description/)
```C++
class Solution {
public:
    int solve(vector<int>& nums, int k) {
        unordered_map<int, int> mp;
        int n = nums.size(), ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            ++ mp[nums[r]];
            while (mp.size() > k) {
                if (-- mp[nums[l]] == 0)    mp.erase(nums[l]);
                ++ l;
            }
            ans += r - l + 1;
        }
        return ans;
    }

    int subarraysWithKDistinct(vector<int>& nums, int k) {
        return solve(nums, k) - solve(nums, k - 1);
    }
};
```

# LC1248. 统计「优美子数组」
[传送门](https://leetcode.cn/problems/count-number-of-nice-subarrays/description/)
```C++
class Solution {
public:
    int solve(vector<int>& nums, int k) {
        int n = nums.size(), odds = 0, ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            odds += (nums[r] & 1);
            while (odds > k) {
                odds -= (nums[l] & 1);
                ++ l;
            }
            ans += r - l + 1;
        }
        return ans;
    }

    int numberOfSubarrays(vector<int>& nums, int k) {
        return solve(nums, k) - solve(nums, k - 1);
    }
};
```


# LC1234. 替换子串得到平衡字符串
[传送门](https://leetcode.cn/problems/replace-the-substring-for-balanced-string/description/)
```C++
class Solution {
public:
    int balancedString(string s) {
        int n = s.size(), m = n / 4, ans = INT_MAX;

        unordered_map<char, int> mp;
        for (auto& c : s)   ++ mp[c];
        if (mp['Q'] == m && mp['W'] == m && mp['E'] == m && mp['R'] == m) {
            return 0;
        }

        for (int l = 0, r = 0; r < n; ++ r) {
            -- mp[s[r]];
            while (mp['Q'] <= m && mp['W'] <= m && mp['E'] <= m && mp['R'] <= m) {
                ans = min(ans, r - l + 1);
                ++ mp[s[l ++ ]];
            }
        }

        return ans;
    }
};
```

# LC1658. 将 x 减到 0 的最小操作数
[传送门](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/description/)
```C++
class Solution {
public:
    int minOperations(vector<int>& nums, int x) {
        int target = accumulate(nums.begin(), nums.end(), 0) - x;
        if (target < 0) return -1;

        int n = nums.size(), s = 0, ans = -1;
        for (int l = 0, r = 0; r < n; ++ r) {
            s += nums[r];
            while (s > target) {
                s -= nums[l ++ ];
            }
            if (s == target)    ans = max(ans, r - l + 1);
        }

        return ans == -1 ? -1 : n - ans;
    }
};
```

# LC1438. 绝对差不超过限制的最长连续子数组
[传送门](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/description/)
```C++
class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        // a队列维护当前窗口的最大值，b队列维护当前窗口的最小值
        deque<int> a, b;

        int n = nums.size(), ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            // 维护最大值队列
            while (!a.empty() && nums[a.back()] < nums[r]) {    // 不能写成等号
                a.pop_back();
            }
            a.push_back(r);

            // 维护最小值队列
            while (!b.empty() && nums[b.back()] > nums[r]) {    // 不能写成等号
                b.pop_back();
            } 
            b.push_back(r);

            // 检查当前窗口的最大值和最小值的差是否小于等于 limit
            while (!a.empty() && !b.empty() && nums[a.front()] - nums[b.front()] > limit) {
                // 移动左边界
                if (l == a.front()) {
                    a.pop_front();
                }
                if (l == b.front()) {
                    b.pop_front();
                }
                ++ l;
            }

            // 更新最长子数组的长度
            ans = max(ans, r - l + 1);
        }

        return ans;
    }
};
```

# LC2875. 无限数组的最短子数组
[传送门](https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/description/)
```C++
class Solution {
public:
    using LL = long long ;
    int minSizeSubarray(vector<int>& nums, int target) {
        int n = nums.size();
        // 计算数组的总和
        LL totalSum = accumulate(nums.begin(), nums.end(), 0ll), s = 0;
        
        // 如果 target 大于 totalSum，我们需要考虑多个完整的 nums 数组
        int cnt = target / totalSum;
        int remainingTarget = target % totalSum;
        
        // 如果 remainingTarget 为 0，说明 target 正好是 totalSum 的整数倍
        if (remainingTarget == 0) {
            return cnt * n;
        }
        
        // 使用滑动窗口寻找最短的子数组，使得其和等于 remainingTarget
        int ans = INT_MAX;
        for (int l = 0, r = 0; r < 2 * n; ++r) {
            s += nums[r % n];
            
            // 如果当前窗口的和大于 remainingTarget，移动左边界
            while (s > remainingTarget) {
                s -= nums[l % n];
                ++ l;
            }
            
            // 如果当前窗口的和等于 remainingTarget，更新最小长度
            if (s == remainingTarget) {
                ans = min(ans, r - l + 1);
            }
        }
        
        // 返回最小长度加上完整的 nums 数组的长度
        return ans == INT_MAX ? -1 : ans + cnt * n;
    }
};
```

# LC2024. 考试的最大困扰度
[传送门](https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/description/?envType=problem-list-v2&envId=7NLUuUun)
```C++
class Solution {
public:
    int maxConsecutiveAnswers(string s, int k) {
        int n = s.size(), ans = 0, t = 0, f = 0;
        // 记录t和f的数量，如果它们而这种最小的那个都大于k，那么不满足，需要收缩窗口
        for (int l = 0, r = 0; r < n; ++ r) {
            if (s[r] == 'T')    ++ t;
            else    ++ f;
            while (min(t, f) > k) {
                if (s[l] == 'T')    -- t;
                else    -- f;
                ++ l;
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC2401. 最长优雅子数组
[传送门](https://leetcode.cn/problems/longest-nice-subarray/description/?envType=problem-list-v2&envId=7NLUuUun)
```C++
class Solution {
public:
    int longestNiceSubarray(vector<int> &nums) {
        int n = nums.size(), ans = 0, orValue = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            while (orValue & nums[r]) { // 有交集
                orValue ^= nums[l ++ ]; // 从orValue中去掉集合nums[l]
            }
            orValue |= nums[r]; // 把集合nums[r]并入orValue中
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

# LC1838. 最高频元素的频数
[传送门](https://leetcode.cn/problems/frequency-of-the-most-frequent-element/description/?envType=problem-list-v2&envId=7NLUuUun)
```C++
class Solution {
public:
    using LL = long long ;
    int maxFrequency(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int n = nums.size(), ans = 1;

        // 计算前缀和
        vector<LL> s(n + 1);
        for (int i = 0; i < n; ++ i)    s[i + 1] = s[i] + nums[i];
        
        for (int l = 0, r = 0; r < n; ++ r) {
            // 计算将 [l, r] 区间内的所有元素变成nums[r]需要的操作次数
            LL cnt = 1ll * (r - l + 1) * nums[r] - (s[r + 1] - s[l]);
            // 如果操作次数超过k，则移动左边界l
            while (cnt > k) {
                cnt -= nums[r] - nums[l];
                ++ l;
            }
            // 更新最大频数
            ans = max(ans, r - l + 1);
        }

        return ans;
    }
};
```

# LC2106. 摘水果
[传送门](https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/description/?envType=problem-list-v2&envId=7NLUuUun)
```C++
class Solution {
public:
    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {
        int n = fruits.size(), ans = 0, s = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            int pos = fruits[r][0], val = fruits[r][1];
            s += val;
            while (pos - fruits[l][0] + min(abs(startPos - fruits[l][0]), abs(pos - startPos)) > k) {
                s -= fruits[l ++ ][1];
            }
            ans = max(ans, s);
        }
        return ans;
    }
};
```

# LCLC2781. 最长合法子字符串的长度
[传送门](https://leetcode.cn/problems/length-of-the-longest-valid-substring/description/?envType=problem-list-v2&envId=7NLUuUun)
```C++
class Solution {
public:
    int longestValidSubstring(string word, vector<string>& forbidden) {
        unordered_set<string> S(forbidden.begin(), forbidden.end());
        int n = word.size(), ans = 0;
        for (int l = 0, r = 0; r < n; ++ r) {
            // i >= l: 确保i不会小于l指针，即确保我们检查的子串在当前窗口内
            // r - i <= 9: 子串区间[i, r]，确保我们检查的子串长度不超过10, 即r - i + 1 <= 10
            for (int i = r; i >= l && r - i <= 9; -- i) {
                if (S.count(word.substr(i, r - i + 1))) {
                    l = i + 1;
                    break;
                }
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```
