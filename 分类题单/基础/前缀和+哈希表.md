# LC560. 和为 K 的子数组
[传送门](https://leetcode.cn/problems/subarray-sum-equals-k/description/)
```C++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int n = nums.size(), ans = 0, s = 0;

        unordered_map<int, int> mp;
        mp[0] = 1;
        for (int i = 1; i <= n; ++ i) {
            s += nums[i - 1];
            if (mp.count(s - k)) {
                ans += mp[s - k];
            }
            ++ mp[s];
        }

        return ans;
    }
};
```

# LC930. 和相同的二元子数组
[传送门](https://leetcode.cn/problems/binary-subarrays-with-sum/description/)
```C++
class Solution {
public:
    int numSubarraysWithSum(vector<int>& nums, int k) {
        int n = nums.size(), ans = 0, s = 0;

        unordered_map<int, int> mp;
        mp[0] = 1;
        for (int i = 1; i <= n; ++ i) {
            s += nums[i - 1];
            if (mp.count(s - k)) {
                ans += mp[s - k];
            }
            ++ mp[s];
        }

        return ans;
    }
};
```

# LC1524. 和为奇数的子数组数目
[传送门](https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/description/)
```C++
class Solution {
public:
    const static int MOD = 1e9 + 7;
    int numOfSubarrays(vector<int>& arr) {
        int n = arr.size(), s = 0, ans = 0;
        unordered_map<int, int> mp;
        mp[0] = 1;
        for (auto& x : arr) {
            s += x;
            if (s & 1) {
                ans = (ans + mp[0]) % MOD;
            } else {
                ans = (ans + mp[1]) % MOD;
            }
            ++ mp[s & 1];
        }
        return ans;
    }
};
```
