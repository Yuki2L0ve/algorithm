# LC560. 和为 K 的子数组
[传送门](https://leetcode.cn/problems/subarray-sum-equals-k/description/)
```C++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int n = nums.size(), ans = 0, s = 0;

        unordered_map<int, int> mp;
        mp[0] = 1;
        for (int i = 1; i <= n; ++ i) {
            s += nums[i - 1];
            if (mp.count(s - k)) {
                ans += mp[s - k];
            }
            ++ mp[s];
        }

        return ans;
    }
};
```

# LC930. 和相同的二元子数组
[传送门](https://leetcode.cn/problems/binary-subarrays-with-sum/description/)
```C++
class Solution {
public:
    int numSubarraysWithSum(vector<int>& nums, int k) {
        int n = nums.size(), ans = 0, s = 0;

        unordered_map<int, int> mp;
        mp[0] = 1;
        for (int i = 1; i <= n; ++ i) {
            s += nums[i - 1];
            if (mp.count(s - k)) {
                ans += mp[s - k];
            }
            ++ mp[s];
        }

        return ans;
    }
};
```

# LC1524. 和为奇数的子数组数目
[传送门](https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/description/)
```C++
class Solution {
public:
    const static int MOD = 1e9 + 7;
    int numOfSubarrays(vector<int>& arr) {
        int n = arr.size(), s = 0, ans = 0;
        unordered_map<int, int> mp;
        mp[0] = 1;
        for (auto& x : arr) {
            s += x;
            if (s & 1) {
                ans = (ans + mp[0]) % MOD;
            } else {
                ans = (ans + mp[1]) % MOD;
            }
            ++ mp[s & 1];
        }
        return ans;
    }
};
```

# LC974. 和可被 K 整除的子数组
[传送门](https://leetcode.cn/problems/subarray-sums-divisible-by-k/description/)
```C++
class Solution {
public:
    int subarraysDivByK(vector<int>& nums, int k) {
        int n = nums.size(), ans = 0, s = 0;
        unordered_map<int, int> mp; // (前缀和 % k, 出现次数)
        mp[0] = 1;

        for (int i = 0; i < n; ++ i) {
            s += nums[i];
            int r = (s % k + k) % k;    // 调整负数的情况
            if (mp.count(r)) {
                ans += mp[r];
                ++ mp[r];   // 之前存过了，则 value 加 1
            } else {
                mp[r] = 1;  // 之前没有存过，则作为 key 存入，value 为 1
            }
        }

        return ans;
    }
};
```

# LC523. 连续的子数组和
[传送门](https://leetcode.cn/problems/continuous-subarray-sum/description/)
```C++
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        long long s = 0;
        unordered_map<int, int> mp; // (前缀和 % k, 下标)
        mp[0] = -1; // 初始化为-1以处理边界条件
        for (int i = 0; i < nums.size(); i++) {
            s += nums[i];
            int r = (s % k + k) % k; // 调整负数的情况
            if (mp.count(r)) {  // 之前存过了
                if (i - mp[r] >= 2) { 
                    return true;
                }
            } else {    // 之前没有存过
                mp[r] = i; 
            }
        }
        
        return false; 
    }
};
```
