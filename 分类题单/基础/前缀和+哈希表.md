# LC560. 和为 K 的子数组
[传送门](https://leetcode.cn/problems/subarray-sum-equals-k/description/)
```C++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int n = nums.size(), ans = 0, s = 0;

        unordered_map<int, int> mp;
        mp[0] = 1;
        for (int i = 1; i <= n; ++ i) {
            s += nums[i - 1];
            if (mp.count(s - k)) {
                ans += mp[s - k];
            }
            ++ mp[s];
        }

        return ans;
    }
};
```

# LC930. 和相同的二元子数组
[传送门](https://leetcode.cn/problems/binary-subarrays-with-sum/description/)
```C++
class Solution {
public:
    int numSubarraysWithSum(vector<int>& nums, int k) {
        int n = nums.size(), ans = 0, s = 0;

        unordered_map<int, int> mp;
        mp[0] = 1;
        for (int i = 1; i <= n; ++ i) {
            s += nums[i - 1];
            if (mp.count(s - k)) {
                ans += mp[s - k];
            }
            ++ mp[s];
        }

        return ans;
    }
};
```

# LC1524. 和为奇数的子数组数目
[传送门](https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/description/)
```C++
class Solution {
public:
    const static int MOD = 1e9 + 7;
    int numOfSubarrays(vector<int>& arr) {
        int n = arr.size(), s = 0, ans = 0;
        unordered_map<int, int> mp;
        mp[0] = 1;
        for (auto& x : arr) {
            s += x;
            if (s & 1) {
                ans = (ans + mp[0]) % MOD;
            } else {
                ans = (ans + mp[1]) % MOD;
            }
            ++ mp[s & 1];
        }
        return ans;
    }
};
```

# LC974. 和可被 K 整除的子数组
[传送门](https://leetcode.cn/problems/subarray-sums-divisible-by-k/description/)
```C++
class Solution {
public:
    int subarraysDivByK(vector<int>& nums, int k) {
        int n = nums.size(), ans = 0, s = 0;
        unordered_map<int, int> mp; // (前缀和 % k, 出现次数)
        mp[0] = 1;

        for (int i = 0; i < n; ++ i) {
            s += nums[i];
            int r = (s % k + k) % k;   
            if (mp.count(r)) {
                ans += mp[r];
            }
            ++ mp[r]
        }

        return ans;
    }
};
```

# LC523. 连续的子数组和
[传送门](https://leetcode.cn/problems/continuous-subarray-sum/description/)
```C++
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        long long s = 0;
        unordered_map<int, int> mp; // (前缀和 % k, 下标)
        mp[0] = -1; // 初始化为-1以处理边界条件
        for (int i = 0; i < nums.size(); i++) {
            s += nums[i];
            int r = (s % k + k) % k; // 调整负数的情况
            if (mp.count(r)) {  // 之前存过了
                if (i - mp[r] >= 2) { 
                    return true;
                }
            } else {    // 之前没有存过
                mp[r] = i;     // 仅在首次找到该余数时记录索引
            }
        }
        
        return false; 
    }
};
```

# LC437. 路径总和 III
[传送门](https://leetcode.cn/problems/path-sum-iii/description/)
```C++
class Solution {
public:
    unordered_map<long long, int> mp;
    int ans;

    void dfs(TreeNode* root, long long s, int k) {
        if (!root)  return ;

        s += root->val;
        if (mp.count(s - k)) {
            ans += mp[s - k];
        }
        ++ mp[s];

        if (root->left) dfs(root->left, s, k);
        if (root->right)    dfs(root->right, s, k);

        -- mp[s];
    }

    int pathSum(TreeNode* root, int targetSum) {
        if (!root)  return 0;
        mp[0] = 1;
        dfs(root, 0, targetSum);
        return ans;
    }
};
```

# LC2588. 统计美丽子数组数目
[传送门](https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/description/)
```C++
class Solution {
public:
    long long beautifulSubarrays(vector<int>& nums) {
        long long ans = 0;
        int n = nums.size(), s = 0;
        unordered_map<int, int> mp;
        mp[0] = 1;

        for (int i = 0; i < n; ++ i) {
            s ^= nums[i];
            if (mp.count(s)) {
                ans += mp[s];
            }
            ++ mp[s];
        }

        return ans;
    }
};
```

# LC525. 连续数组
[传送门](https://leetcode.cn/problems/contiguous-array/)
```C++
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        int n = nums.size(), s = 0, ans = 0;
        // 用于存储前缀和以及首次出现该前缀和的索引
        unordered_map<int, int> mp;
        mp[0] = -1;

        for (int i = 0; i < n; ++ i) {
            s += (nums[i] == 1 ? 1 : -1);   // 将0视为-1，1视为1
            if (mp.count(s)) {  // 如果这个前缀和之前出现过
                ans = max(ans, i - mp[s]);
            } else {    // 如果是首次出现这个前缀和，记录索引
                mp[s] = i;
            }
        }

        return ans;
    }
};
```

# LC3026. 最大好子数组和
[传送门](https://leetcode.cn/problems/maximum-good-subarray-sum/description/)
```C++
class Solution {
public:
    using LL = long long ;
    long long maximumSubarraySum(vector<int>& nums, int k) {
        unordered_map<int, LL> mp;  // (当前元素x, 从数组起始到当前元素(包含)的前缀和)
        LL ans = LONG_MIN, s = 0;

        for (auto& x : nums) {
            s += x;
            
            if (mp.count(x - k)) {
                ans = max(ans, s - mp[x - k] + x - k);
            }
            if (mp.count(x + k)) {
                ans = max(ans, s - mp[x + k] + x + k);
            }

            if (mp.count(x)) {
                mp[x] = min(mp[x], s);
            } else {
                mp[x] = s;
            }
        }

        return ans == LONG_MIN ? 0 : ans;
    }
};
```
