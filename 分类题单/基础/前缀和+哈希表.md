这类题万变不离其宗，都是会有如下特点：
+ 求子数组的和的个数，一般定义哈希表：(前缀和，该前缀和的出现次数)。可以看这篇[博客](https://leetcode.cn/problems/count-subarrays-with-median-k/solutions/2172092/javapythonwen-ti-zhuan-hua-qian-zhui-he-ysf1b/)
+ 求子数组和的最大/最小长度，一般定义哈希表：(前缀和，该前缀和的首次出现索引下标)。可以看这篇[博客](https://leetcode.cn/problems/make-sum-divisible-by-p/solutions/2159199/java-pythonqian-zhui-he-ha-xi-biao-de-de-l8rh/)


# LC560. 和为 K 的子数组
[传送门](https://leetcode.cn/problems/subarray-sum-equals-k/description/)
```C++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int n = nums.size(), ans = 0, s = 0;

        unordered_map<int, int> mp{{0, 1}}; // (前缀和，该前缀和的出现次数)
        for (auto& x : nums) {
            s += x; // 当枚举到i时，执行完这一行，此时s表示[0, i+1)的前缀和
            if (mp.count(s - k)) {
                ans += mp[s - k];
            }
            ++ mp[s];
        }

        return ans;
    }
};
```

# LC930. 和相同的二元子数组
[传送门](https://leetcode.cn/problems/binary-subarrays-with-sum/description/)
```C++
class Solution {
public:
    int numSubarraysWithSum(vector<int>& nums, int k) {
        int n = nums.size(), ans = 0, s = 0;

        unordered_map<int, int> mp;
        mp[0] = 1;
        for (int i = 1; i <= n; ++ i) {
            s += nums[i - 1];
            if (mp.count(s - k)) {
                ans += mp[s - k];
            }
            ++ mp[s];
        }

        return ans;
    }
};
```

# LC1524. 和为奇数的子数组数目
[传送门](https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/description/)
```C++
class Solution {
public:
    const static int MOD = 1e9 + 7;
    int numOfSubarrays(vector<int>& arr) {
        int n = arr.size(), s = 0, ans = 0;
        unordered_map<int, int> mp;
        mp[0] = 1;
        for (auto& x : arr) {
            s += x;
            if (s & 1) {
                ans = (ans + mp[0]) % MOD;
            } else {
                ans = (ans + mp[1]) % MOD;
            }
            ++ mp[s & 1];
        }
        return ans;
    }
};
```

# LC974. 和可被 K 整除的子数组
[传送门](https://leetcode.cn/problems/subarray-sums-divisible-by-k/description/)
```C++
class Solution {
public:
    int subarraysDivByK(vector<int>& nums, int k) {
        int n = nums.size(), ans = 0, s = 0;
        unordered_map<int, int> mp; // (前缀和 % k, 出现次数)
        mp[0] = 1;

        for (int i = 0; i < n; ++ i) {
            s += nums[i];
            int r = (s % k + k) % k;   
            if (mp.count(r)) {
                ans += mp[r];
            }
            ++ mp[r]
        }

        return ans;
    }
};
```

# LC523. 连续的子数组和
[传送门](https://leetcode.cn/problems/continuous-subarray-sum/description/)
```C++
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        long long s = 0;
        unordered_map<int, int> mp; // (前缀和 % k, 下标)
        mp[0] = -1; // 初始化为-1以处理边界条件
        for (int i = 0; i < nums.size(); i++) {
            s += nums[i];
            int r = (s % k + k) % k; // 调整负数的情况
            if (mp.count(r)) {  // 之前存过了
                if (i - mp[r] >= 2) { 
                    return true;
                }
            } else {    // 之前没有存过
                mp[r] = i;     // 仅在首次找到该余数时记录索引
            }
        }
        
        return false; 
    }
};
```

# LC437. 路径总和 III
[传送门](https://leetcode.cn/problems/path-sum-iii/description/)
```C++
class Solution {
public:
    unordered_map<long long, int> mp;
    int ans;

    void dfs(TreeNode* root, long long s, int k) {
        if (!root)  return ;

        s += root->val;
        if (mp.count(s - k)) {
            ans += mp[s - k];
        }
        ++ mp[s];

        if (root->left) dfs(root->left, s, k);
        if (root->right)    dfs(root->right, s, k);

        -- mp[s];
    }

    int pathSum(TreeNode* root, int targetSum) {
        if (!root)  return 0;
        mp[0] = 1;
        dfs(root, 0, targetSum);
        return ans;
    }
};
```

# LC2588. 统计美丽子数组数目
[传送门](https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/description/)
```C++
class Solution {
public:
    long long beautifulSubarrays(vector<int>& nums) {
        long long ans = 0;
        int n = nums.size(), s = 0;
        unordered_map<int, int> mp;
        mp[0] = 1;

        for (int i = 0; i < n; ++ i) {
            s ^= nums[i];
            if (mp.count(s)) {
                ans += mp[s];
            }
            ++ mp[s];
        }

        return ans;
    }
};
```

# LC525. 连续数组
[传送门](https://leetcode.cn/problems/contiguous-array/)
```C++
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        int n = nums.size(), s = 0, ans = 0;
        // 用于存储前缀和以及首次出现该前缀和的索引
        unordered_map<int, int> mp;
        mp[0] = -1;

        for (int i = 0; i < n; ++ i) {
            s += (nums[i] == 1 ? 1 : -1);   // 将0视为-1，1视为1
            if (mp.count(s)) {  // 如果这个前缀和之前出现过
                ans = max(ans, i - mp[s]);
            } else {    // 如果是首次出现这个前缀和，记录索引
                mp[s] = i;
            }
        }

        return ans;
    }
};
```

# LC1124. 表现良好的最长时间段
[传送门](https://leetcode.cn/problems/longest-well-performing-interval/description/)
```C++
class Solution {
public:
    int longestWPI(vector<int>& hours) {
        int n = hours.size(), s = 0, ans = 0;
        unordered_map<int, int> mp;

        for (int i = 0; i < n; ++ i) {
            s += hours[i] > 8 ? 1 : -1;
            if (s > 0) {
                ans = max(ans, i + 1);
            } else {
                if (mp.count(s - 1)) {
                    ans = max(ans, i - mp[s - 1]);
                }
            }
            if (!mp.count(s)) {
                mp[s] = i;
            }
        }

        return ans;
    }
};
```

# LC3026. 最大好子数组和
[传送门](https://leetcode.cn/problems/maximum-good-subarray-sum/description/)
```C++
class Solution {
public:
    using LL = long long ;
    long long maximumSubarraySum(vector<int>& nums, int k) {
        unordered_map<int, LL> mp;  // (当前元素x, 从数组起始到当前元素(包含)的前缀和)
        LL ans = LONG_MIN, s = 0;

        for (auto& x : nums) {
            s += x;
            
            if (mp.count(x - k)) {
                ans = max(ans, s - mp[x - k] + x - k);
            }
            if (mp.count(x + k)) {
                ans = max(ans, s - mp[x + k] + x + k);
            }

            if (mp.count(x)) {
                mp[x] = min(mp[x], s);
            } else {
                mp[x] = s;
            }
        }

        return ans == LONG_MIN ? 0 : ans;
    }
};
```

# LC1546. 和为目标值且不重叠的非空子数组的最大数目
[传送门](https://leetcode.cn/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/description/)
```C++
class Solution {
public:
    int maxNonOverlapping(vector<int>& nums, int target) {
        int n = nums.size(), s = 0, ans = 0;
        unordered_map<int, int> mp;	// (前缀和，下标)
        mp[0] = -1;

        for (int i = 0; i < n; ++ i) {
            s += nums[i];
            if (mp.count(s - target)) {
                ++ ans; 
                mp.clear(); 
            }
            mp[s] = i;
        }
        
        return ans;
    }
};
```

# LC面试题 17.05. 字母与数字
[传送门](https://leetcode.cn/problems/find-longest-subarray-lcci/)
```C++
class Solution {
public:
    vector<string> findLongestSubarray(vector<string>& array) {
        int n = array.size(), len = 0, s = 0, idx = -1;
        // (从下标0到下标i的前缀和，该前缀和首次出现的索引下标)
        unordered_map<int, int> mp;
        // 注意不能初始化为0，由于空前缀的前缀和是0且对应下标-1
        // 因此首先将前缀和与下标-1存入哈希表
        mp[0] = -1;

        for (int i = 0; i < n; ++ i) {
            s += isalpha(array[i][0]) ? 1 : -1;
            if (mp.count(s)) {
                if (i - mp[s] > len) {
                    len = i - mp[s];
                    idx = mp[s] + 1;
                }
            } else {
                mp[s] = i;
            }
        }

        if (!len)   return {};
        return vector<string>(array.begin() + idx, array.begin() + idx + len);
    }
};
```

# LC2488. 统计中位数为 K 的子数组
[传送门](https://leetcode.cn/problems/count-subarrays-with-median-k/description/)
```C++
class Solution {
public:
    int countSubarrays(vector<int>& nums, int k) {
        int n = nums.size(), kIdx = -1, s = 0, ans = 0;
        for (int i = 0; i < n; ++ i) {
            if (nums[i] == k) {
                kIdx = i;
                break;
            }
        }

        unordered_map<int, int> mp;
        mp[0] = 1;
        for (int i = 0; i < n; ++ i) {
            s += (nums[i] == k ? 0 : (nums[i] > k ? 1 : -1));
            if (i < kIdx) {
                ++ mp[s];
            } else {
                ans += mp[s] + mp[s - 1];
            }
        }

        return ans;
    }
};
```

# LC1590. 使数组和能被 P 整除
[传送门](https://leetcode.cn/problems/make-sum-divisible-by-p/description/)
```C++
class Solution {
public:
    int minSubarray(vector<int> &nums, int p) {
        int x = accumulate(nums.begin(), nums.end(), 0LL) % p;
        if (x == 0) return 0; // 移除空子数组

        int n = nums.size(), ans = n, s = 0;
        // (前缀和的模值，前缀和的模值最后出现的索引下标)
        unordered_map<int, int> mp;
        mp[0] = -1;

        for (int i = 0; i < n; ++ i) {
            s = (s + nums[i]) % p;
            if (mp.count((s - x + p) % p)) {
                ans = min(ans, i - mp[(s - x + p) % p]);
            }
            mp[s] = i;
        }

        return ans == n ? -1 : ans;
    }
};
```
