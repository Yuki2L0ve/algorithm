# LC1310. 子数组异或查询
[传送门](https://leetcode.cn/problems/xor-queries-of-a-subarray/description/)

```C++
class Solution {
public:
    vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
        int n = arr.size(), m = queries.size();
        vector<int> s(n + 1), ans(m);
        for (int i = 0; i < n; ++ i) {
            s[i + 1] = s[i] ^ arr[i];
        }

        for (int i = 0; i < m; ++ i) {
            int l = queries[i][0], r = queries[i][1];
            ans[i] = s[r + 1] ^ s[l];
        }

        return ans;
    }
};
```

# LCLC1371. 每个元音包含偶数次的最长子字符串
[传送门](https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/description/)
```C++
class Solution {
public:
    int findTheLongestSubstring(string str) {
        int n = str.size(), s = 0, ans = 0;
        // (二进制状态，该二进制状态首次出现的下标)
        unordered_map<int, int> mp{{0, -1}};
        for (int i = 0; i < n; ++ i) {
            char c = str[i];
            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {
                s ^= 1 << (c - 'a');
            }
            if (!mp.count(s)) { // 检查当前状态是否出现过
                mp[s] = i;  // 记录该状态第一次出现的位置
            } else {
                ans = max(ans, i - mp[s]);  // 更新最长子字符串的长度
            }
        }
        return ans;
    }
};
```

# LC1177. 构建回文串检测
[传送门](https://leetcode.cn/problems/can-make-palindrome-from-substring/description/)

```C++
class Solution {
public:
    vector<bool> canMakePaliQueries(string str, vector<vector<int>>& queries) {
        int n = str.size();
        vector<vector<int>> s(26, vector<int>(n + 1));
        for (int i = 0; i < 26; ++ i) {
            for (int j = 0; j < n; ++ j) {
                s[i][j + 1] = s[i][j] + (i + 'a' == str[j]);
            }
        }

        vector<bool> ans;
        for (auto& q : queries) {
            int l = q[0], r = q[1], k = q[2], cnt = 0;
            for (int i = 0; i < 26; ++ i) {
                if ((s[i][r + 1] - s[i][l]) % 2) {
                    ++ cnt;
                }
            }
            ans.push_back(cnt / 2 <= k);
        }

        return ans;
    }
};
```

# LC1542. 找出最长的超赞子字符串
[传送门](https://leetcode.cn/problems/find-longest-awesome-substring/description/)
```C++
class Solution {
public:
    int longestAwesome(string s) {
        unordered_map<int, int> mp{{0, -1}};
        // mask用来表示当前字符的奇偶性状态。mask 的每一位对应一个字符（数字 0-9）的奇偶性，1 表示该字符出现了奇数次，0 表示该字符出现了偶数次
        int n = s.size(), mask = 0, ans = 0;
        for (int i = 0; i < n; ++ i) {
            // 回文串中每个字符都出现偶数次
            mask ^= 1 << (s[i] - '0');
            if (mp.count(mask)) {
                ans = max(ans, i - mp[mask]);
            } else {
                mp[mask] = i;
            }

            // 回文串中最多只有一个字符出现奇数次
            for (int j = 0; j < 10; ++ j) { // 枚举哪个数字出现奇数次
                int _mask = mask ^ (1 << j);
                if (mp.count(_mask)) {
                    ans = max(ans, i - mp[_mask]);
                }
            }
        }
        return ans;
    }
};
```
