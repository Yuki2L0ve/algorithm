下面展示如何只使用位运算就能实现加减乘除：

[左神视频](https://www.bilibili.com/video/BV1up4y1g7d8/?p=1&vd_source=a9ee82b2045abbbc7362e3575b7181fb)

[左神代码](https://github.com/algorithmzuo/algorithm-journey/blob/main/src/class033/BitOperationAddMinusMultiplyDivide.java)

# 加法
```C++
int add(int a, int b) {
    int ans = a;
    while (b) {
        ans = a ^ b;    // a ^ b表示a和b无进位相加的结果
        b = (a & b) << 1;   // (a & b) << 1表示a和b相加时的进位信息
        a = ans;
    }
    return ans;
}
```

# 减法
```C++
int sub(int a, int b) {
    return add(a, neg(b));
}

// 这个函数是求-x，它用位运算来表达就是 ~x + 1
int neg(int x) {
    return add(~x, 1);
}
```

# 乘法
```C++
int mul(int a, int b) {    // 这个也叫做龟速乘，特别适合 a * b % MOD，其中a和b都是特别大的整数
    int ans = 0;
    while (b) {
        if (b & 1)  ans = add(ans, a);
        add(a, a);
        b >>= 1;
    }
    return ans;
}
```


# 除法
```C++
int div(int a, int b) { // 注意：调用这个方法时必须保证a和b都不是整数最小值(INT_MIN, LONG_MIN)
    bool sign = a < 0 ^ b < 0;
    int x = a < 0 ? neg(a) : a;
    int y = b < 0 ? neg(b) : b;
    int ans = 0;
    for (int i = 30; i >= 0; i = sub(i, 1)) {
        if (x >> i >= y) {
            ans |= 1 << i;
            x = sub(x, y << i);
        }
    }
    return sign ? neg(ans) : ans;
}
```

> 特别需要注意的是：调用div这个方法时必须保证a和b都不是整数最小值(INT_MIN, LONG_MIN)

有个很恶心的除法题目：

[LC29. 两数相除](https://leetcode.cn/problems/divide-two-integers/description/)
