[灵神总结](https://leetcode.cn/circle/discuss/mOr1u6/)


![image](https://github.com/user-attachments/assets/36579fa8-ff7c-49da-8c7c-1b82c5c43d87)

# LC1 两数之和
[传送门](https://leetcode.cn/problems/two-sum/)

```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> mp;
        for (int i = 0; i < nums.size(); ++ i) {
            if (mp.count(target - nums[i])) {
                return {mp[target - nums[i]], i};
            }
            mp[nums[i]] = i;
        }
        return {};
    }
};
```

# LC2260. 必须拿起的最小连续卡牌数
[传送门](https://leetcode.cn/problems/minimum-consecutive-cards-to-pick-up/description/)

```C++
class Solution {
public:
    int minimumCardPickup(vector<int>& cards) {
        int ans = INT_MAX;
        unordered_map<int, int> mp;
        for (int i = 0; i < cards.size(); ++ i) {
            if (mp.count(cards[i])) {
                ans = min(ans, i - mp[cards[i]] + 1);
            }
            mp[cards[i]] = i;
        }
        return ans == INT_MAX ? -1 : ans;
    }
};
```

# LC1512. 好数对的数目
[传送门](https://leetcode.cn/problems/number-of-good-pairs/description/)

```C++
class Solution {
public:
    int numIdenticalPairs(vector<int>& nums) {
        int ans = 0;
        unordered_map<int, int> mp;
        for (auto& x : nums) {
            if (mp.count(x))    ans += mp[x];
            ++ mp[x];
        }
        return ans;
    }
};
```

# LC121 买卖股票的最佳时机
[传送门](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int ans = 0, low = INT_MAX;
        for (auto& x : prices) {
            ans = max(ans, x - low);
            low = min(low, x);
        }
        return ans;
    }
};
```

# LC2815. 数组中的最大数对和
[传送门](https://leetcode.cn/problems/max-pair-sum-in-an-array/description/)

```C++
class Solution {
public:
    int maxSum(vector<int>& nums) {
        int ans = -1;
        // 定义一个大小为10的哈希表，mp[d]表示最大数位为d时所对应的那个整数
        vector<int> mp(10, INT_MIN);
        for (auto& v : nums) {
            int d = 0;  // 初始化当前数 v 的最大数位为0
            for (int x = v; x; x /= 10) {
                d = max(d, x % 10);
            }
            ans = max(ans, v + mp[d]);
            mp[d] = max(mp[d], v);
        }
        return ans;
    }
};
```

# LC2342. 数位和相等数对的最大和
[传送门](https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/description/)

```C++
class Solution {
public:
    int maximumSum(vector<int>& nums) {
        int ans = -1;
        // mp[s]表示数位和为s时所对应的那个最大数
        unordered_map<int, int> mp; 
        for (auto& v : nums) {
            int s = 0;
            for (int x = v; x; x /= 10) {
                s += x % 10;
            }
            if (mp.count(s)) {
                ans = max(ans, v + mp[s]);
            }
            mp[s] = max(mp[s], v);
        }
        return ans;
    }
};
```

# LC1679. K 和数对的最大数目
[传送门](https://www.yuque.com/camellia_/zm0aqy/wwuavb8biz8r4puq)
```C++
class Solution {
public:
    int maxOperations(vector<int>& nums, int k) {
        int ans = 0;
        unordered_map<int, int> mp;
        for (auto& x : nums) {
            if (mp.count(k - x) && mp[k - x]) {
                -- mp[k - x];
                ++ ans;
            } else {
                ++ mp[x];
            }
        }
        return ans;
    }
};
```

