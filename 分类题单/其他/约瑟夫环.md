# LCR 187. 破冰游戏
[传送门](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/description/)
```C++
class Solution {
public:
    int iceBreakingGame(int n, int m) {
        vector<int> t(n);
        for (int i = 0; i < n; ++ i) {
            t[i] = i;
        }

        int pos = 0, ans = 0;
        for (int i = 0; i < n; ++ i) {
            pos = (pos + m - 1) % t.size();
            if (i == n - 1) {   // 最后一个存活的人
                ans = *(t.begin() + pos);
            }
            t.erase(t.begin() + pos);
        }

        return ans;
    }
};
```
```C++
class Solution {
public:
    int iceBreakingGame(int n, int m) {
        int pos = 0; // 最终活下来那个人的初始位置
        // i表示这一轮的人数  一直做到最初有n个人时 最终胜利者的位置
        for (int i = 2; i <= n; ++ i) {
            pos = (pos + m) % i;  // 每次循环右移
        }
        // 这题的编号是从0开始,因此直接返回数组下标pos就是正确的编号
        // 如果题目的编号是从1开始,但是由于我们的数组下标是从0开始,那么此时输出答案时就要数组下标pos+1,才能转成编号
        return pos;
    }
};
```


# P1996 约瑟夫问题
[传送门](https://www.luogu.com.cn/problem/P1996)
```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
int ne[N], n, m;

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; ++ i)    ne[i] = i + 1;
    ne[n] = 1; // 注意是让n连向1而不是连向0
    
    int p = 0;  // 0是一个虚拟节点，方便删除操作的
    for (int i = 1; i <= n; ++ i) {
        for (int j = 1; j < m; ++ j) {
            p = ne[p];
        }
        printf("%d ", ne[p]);
        ne[p] = ne[ne[p]];
    }
}   
```
```C++
#include <bits/stdc++.h>
using namespace std;
int n, m;

int main() {
    scanf("%d%d", &n, &m);
    vector<int> t;  // t模拟这个 约瑟夫环
    // 初始化t存储每个人的编号（编号是从1开始的）
    for (int i = 0; i < n; ++ i)   t.push_back(i + 1);
    int pos = 0;    // 找到要出圈的那个人的索引下标
    for (int i = 0; i < n; ++ i) {	// 循环淘汰出局n个人
        // 找到了要出圈的那个人的位置，其实pos也就是t中的下标
        // 之所以是pos+m-1是因为计数包括当前位置的人
        pos = (pos + m - 1) % t.size();
        // 通过*(t+pos)也就是得到了要出圈的那个人的编号了
        printf("%d ", *(t.begin() + pos));
        // 从t中删除要出圈的这个人的下标
        // 使用动态数组vector的好处就在这里,可以动态的调整这个数组
        t.erase(t.begin() + pos);
    }
}
```
```c++
#include <bits/stdc++.h>
using namespace std;
int n, m;

int main() {
    scanf("%d%d", &n, &m);
    list<int> t;
    // 初始化链表，将1到n的编号依次加入链表
    for (int i = 0; i < n; ++ i)   t.push_back(i + 1);

    auto it = t.begin();    // 迭代器指向链表的开始
    while (!t.empty()) {    // 当链表非空时执行
        // 步进(m-1)次，因为每次循环时，it已经指向了下一个开始报数的人
        for (int step = 1; step < m; ++step) {
            ++ it;
            // 如果迭代器到达链表末尾，回到链表开始
            if (it == t.end())  it = t.begin();
        }
        printf("%d ", *it); // 输出要删除的人的编号
        it = t.erase(it);   // 删除元素，并将迭代器移动到下一个元素
        // 如果迭代器到达链表末尾，回到链表开始
        if (it == t.end())  it = t.begin();
    }
}
```

# P1145 约瑟夫
[传送门](https://www.luogu.com.cn/problem/P1145)
```C++
#include <bits/stdc++.h>
using namespace std;
int k;  // 好人编号[0, k-1] 坏人编号[k, 2k-1]

bool check(int m) {
    vector<int> t(2 * k);
    iota(t.begin(), t.end(), 0);

    int pos = 0, cnt = 0;   // cnt记录杀死坏人的数量
    while (!t.empty()) {
        pos = (pos + m - 1) % t.size();
        if (t[pos] >= k) {  // 杀死的是坏人
            ++ cnt;
            if (cnt == k) { // 杀死了后面的k个坏人
                return true;
            }
        } else {    // 杀死的是好人
            return false;
        }
        t.erase(t.begin() + pos);
    }

    return false;
}

int main() {
    scanf("%d", &k);
    int m = k + 1;  // 显然m至少要从k+1开始取
    while (1) {
        if (check(m)) {
            printf("%d\n", m);
            return 0;
        }
        ++ m;
    }
}
```

# hdu4841 圆桌问题
[传送门](https://acm.hdu.edu.cn/showproblem.php?pid=4841)
```C++
#include <bits/stdc++.h>
using namespace std;
int n, m;

int main() {
    while (~scanf("%d%d", &n, &m)) {
        vector<int> t(2 * n);
        iota(t.begin(), t.end(), 0);
        int pos = 0;
        for (int i = 0; i < n; ++ i) {  // 删除这n个坏人
            pos = (pos + m - 1) % t.size();
            t.erase(t.begin() + pos);
        }

        // 经过上面的步骤后，就删除了这n个坏人，那么此时t中存储的就是剩下的n个好人了
        int j = 0;  // j是记录此时遍历到了t中的那个下标
        // 根据原来的这2n个人的编号，与此时t中的编号比较
        // 如果相等，则说明此时的编号i是好人，否则就说明是坏人
        for (int i = 0; i < 2 * n; ++ i) {
            if (j < t.size() && i == t[j]) {    // 说明i是好人
                printf("G");
                ++ j;
            } else {    // 说明i是坏人
                printf("B");
            }

            if (i > 0 && i % 50 == 0)   puts("");
        }
        puts("");
    }
}
```
